{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;;AAAA,iEAAe,cAAc,EAAE,UAAU,EAAE,eAAe,EAAE,gBAAgB,EAAE,UAAU,GAAG,yCAAyC;;;;;;;;;;;;;;ACApI;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;AClBqC;AACrC;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,SAAS;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA,0gBAA0gB;AAC1gB;AACA;AACA;AACA;;AAEA,OAAO,wDAAQ;AACf;AACA;;AAEA;AACA;;AAEA,iEAAe,SAAS;;;;;;;;;;;;;;;;AC7BG;AACY;;AAEvC;AACA;AACA,+CAA+C,+CAAG,KAAK;;AAEvD;AACA,mCAAmC;;AAEnC;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA;AACA;;AAEA,SAAS,yDAAS;AAClB;;AAEA,iEAAe,EAAE;;;;;;;;;;;;;;;ACvBc;;AAE/B;AACA,qCAAqC,sDAAU;AAC/C;;AAEA,iEAAe,QAAQ;;;;;;;;;;;;;;;;ACNG;AACS;AACnC;AACA;AACA;AACA,qBAAqB,8CAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,UAAU;AACzC;AACA,kCAAkC,6CAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;AC3KU;AACnC;AACA;AACA,qBAAqB,8CAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,EAAE;AACP;AACA;AACA;AACA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;;;;AChC8B;AACF;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAY;AAC5B,wDAAwD;AACxD;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mEAA2B;AACtC,qCAAqC,uBAAuB;AAC5D;AACA,WAAW,8DAAsB;AACjC,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,aAAa;AACtE,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mEAA2B;AACtD,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ,GAAG,KAAK;AAC7B,aAAa,IAAI,GAAG,SAAS;AAC7B,aAAa,QAAQ,GAAG,KAAK;AAC7B,aAAa,IAAI,GAAG,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA,gCAAgC,sBAAsB;AACtD;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sDAAc;AAC/C;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC,0BAA0B,WAAW,GAAG,YAAY;AACpD;AACA;AACA;AACA;AACA,iDAAiD,WAAW,GAAG,YAAY;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,aAAa,iBAAiB,YAAY;AAC1F;AACA;AACA,+DAA+D,WAAW;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iBAAiB,oEAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mEAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iBAAiB,+DAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+DAAuB;AACtC;AACA;AACA,eAAe,oEAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8DAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;ACjhBe;AACC;AACpC;AACA;AACA;AACA;AACA,gBAAgB,8CAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;;AC3Lc;AACC;AACpC;AACA;AACA;AACA;AACA,cAAc,8CAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,EAAE;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,UAAU,gDAAM;AAChB;AACA;AACA;AACA,oBAAoB,wDAAwD;AAC5E;AACA,mBAAmB,wDAAwD;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;;;AC9RiC;AACtB;AACT;AACc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAY;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,IAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB,oEAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,UAAU;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uEAA+B;AAC1C,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oEAA4B;AAC3C;AACA;AACA,eAAe,6DAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iBAAiB,6DAAqB;AACtC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6CAAI;AACxB;AACA;AACA;AACA;AACA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;AC7Qb;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACZe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UCjCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNA;;;;;;;;;;;;;;;;;;;;;;ACA0B;AACA;AACU;AACF;AACN;AAC5B;AACkD","sources":["webpack://Conquer/./node_modules/uuid/dist/esm-browser/regex.js","webpack://Conquer/./node_modules/uuid/dist/esm-browser/rng.js","webpack://Conquer/./node_modules/uuid/dist/esm-browser/stringify.js","webpack://Conquer/./node_modules/uuid/dist/esm-browser/v4.js","webpack://Conquer/./node_modules/uuid/dist/esm-browser/validate.js","webpack://Conquer/./src/js/DashBoard.js","webpack://Conquer/./src/js/DragAndDrop.js","webpack://Conquer/./src/js/Game.js","webpack://Conquer/./src/js/Login.js","webpack://Conquer/./src/js/Register.js","webpack://Conquer/./src/js/Room.js","webpack://Conquer/./src/js/constants.js","webpack://Conquer/./src/js/utils.js","webpack://Conquer/webpack/bootstrap","webpack://Conquer/webpack/runtime/define property getters","webpack://Conquer/webpack/runtime/hasOwnProperty shorthand","webpack://Conquer/webpack/runtime/make namespace object","webpack://Conquer/./src/sass/style.scss?3ac4","webpack://Conquer/./src/js/index.js"],"sourcesContent":["export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import Room from \"./Room\";\r\nimport LocalStorage from \"./utils\";\r\n\r\nclass Dashboard {\r\n  roomsList = [];\r\n  localStorage = new LocalStorage();\r\n  avatarMobile;\r\n\r\n  constructor(initData) {\r\n    this.boxRooms = initData.boxRooms;\r\n  }\r\n\r\n  init() {\r\n    this.redirectToLogin();\r\n    this.generateRooms();\r\n    this.generatePlayerBox();\r\n    this.generateLogout();\r\n    this.avatarMobile = document.querySelector(\"#avatarMobile\");\r\n    //this.avatarMobile = new D\r\n    avatarMobile.addEventListener(\r\n      \"dragstart\", this.dragIniciado.bind(this),     \r\n      false\r\n    );\r\n    avatarMobile.addEventListener(\r\n      \"dragend\", this.dragFinalizado.bind(this),\r\n      false\r\n    );\r\n  }\r\n\r\n  dragIniciado(e) {\r\n    console.log(\"me arrastrooo\");\r\n    //let padre = document.createElement(\"div\");\r\n    //let clon = this.avatarMobile;\r\n    //padre.appendChild(clon);\r\n    e.dataTransfer.setData(\"userAvatar\",\"avatarMobile\");\r\n  }\r\n  \r\n  dragFinalizado() {\r\n    console.log(\"me solteeee\");\r\n    \r\n  }\r\n\r\n\r\n  generateRooms() {\r\n    this.boxRooms.forEach((box, index) => {\r\n      const roomName = `Room ${index + 1}`;\r\n      // Generamos las instancias de las salas\r\n      this.roomsList[index] = new Room(box.id, roomName, 4);\r\n      // Iniciamos listeners para eventos del tipo storage\r\n      this.roomsList[index].initStorageEvents();\r\n      this.roomsList[index].initDragListeners();\r\n\r\n      const boxDiv = document.getElementById(box.id);\r\n\r\n      // Añadir evento en alguna parte del box para cuando se hace drag&drop\r\n      // Y que conecte con un método de la instancia de room\r\n\r\n      // Añadir clase para pintar caja\r\n      boxDiv.classList.add(`room${index + 1}`);\r\n      // Añadir títulos\r\n      const boxDivHeader = document.querySelector(\r\n        `#${box.id} .m-room-drop-item__header h3`\r\n      );\r\n      boxDivHeader.innerHTML = roomName;\r\n    });\r\n\r\n    this.generateStorageRooms();\r\n  }\r\n\r\n  generateStorageRooms() {\r\n    // Comprobamos si ya hay rooms en el LocalStorage\r\n    const existRooms = this.localStorage.getLocalStorage(\"roomsList\");\r\n    if (!existRooms) {\r\n      // Generamos localStorage inicial para las rooms\r\n      const roomsDataToStorage = this.roomsList.map((room) => ({\r\n        id: room.id,\r\n        usersRoom: [],\r\n        isOpen: true,\r\n        game: {\r\n          grid: [],\r\n          players: [],\r\n          defeatedPlaters: [],\r\n          totalCellsToWin: 0,\r\n          round: {\r\n            turn: 0,\r\n            roundNumber: 0,\r\n            player: null,\r\n          },\r\n        },\r\n      }));\r\n      const roomsDataType = {\r\n        eventType: null,\r\n        roomEventId: null,\r\n        rooms: roomsDataToStorage,\r\n      };\r\n      this.localStorage.setLocalStorage(\"roomsList\", roomsDataType);\r\n    }\r\n\r\n    //Temporal, añadimos user a la primera sala\r\n    // const currentUserData = this.localStorage.getLocalStorage(\"me\", \"session\");\r\n    // const currentRoom = this.roomsList[0];\r\n    // currentRoom.addToRoom(currentUserData);\r\n  }\r\n\r\n  generatePlayerBox() {\r\n    const data = this.localStorage.getLocalStorage(\"me\", \"session\");\r\n\r\n    if (data) {\r\n      const player = data;\r\n      const boxDiv = document.getElementById(\"my-user-box\");\r\n      const avatarDiv = boxDiv.querySelector(\".a-avatar\");\r\n      const nameDiv = boxDiv.querySelector(\".m-user-item__name\");\r\n      const roomDiv = boxDiv.querySelector(\".m-user-item__room\");\r\n      const roomName = this.getRoomName(player.favouriteRoom);\r\n\r\n      nameDiv.innerText = player.name;\r\n      roomDiv.innerText = roomName;\r\n      avatarDiv.dataset.id = player.id;\r\n      avatarDiv.dataset.avatar = player.avatar;\r\n      avatarDiv.dataset.color = player.color;\r\n      avatarDiv.classList.add(player.avatar);\r\n\r\n      if (this.isPlayerInRooms(player)) {\r\n        avatarDiv.classList.add(\"hidden\");\r\n      } else {\r\n        avatarDiv.classList.remove(\"hidden\");\r\n      }\r\n    } else {\r\n      // Aquí va la redicción si el usuario no esta conectado;\r\n      console.log(\"usuario no conectado\");\r\n    }\r\n  }\r\n\r\n  generateLogout() {\r\n    const logoutBtn = document.getElementById(\"logout\");\r\n    const player = this.localStorage.getLocalStorage(\"me\", \"session\");\r\n\r\n    logoutBtn.addEventListener(\"click\", function () {\r\n      this.rooms.takeOutFromRoom(player);\r\n      this.localStorage.setLocalStorage(\"me\", null, \"session\");\r\n      this.redirectToLogin();\r\n    });\r\n  }\r\n\r\n  isPlayerInRooms(player) {\r\n    let allPlayers = [];\r\n    this.roomsList.forEach((room) => {\r\n      allPlayers.concat(room.players);\r\n    });\r\n    return !!allPlayers.find((pl) => pl.id === player.id);\r\n  }\r\n\r\n  getRoomName(id) {\r\n    let index = -1;\r\n    this.boxRooms.find(function (item, i) {\r\n      if (item.id === id) {\r\n        index = i;\r\n        return i;\r\n      }\r\n    });\r\n    return \"ROOM \" + (index + 1);\r\n  }\r\n\r\n  redirectToLogin() {\r\n    let user = this.localStorage.getLocalStorage(\"me\", \"session\");\r\n    if (!user) {\r\n      window.location.href = \"/\";\r\n    }\r\n  }\r\n}\r\n\r\nexport default Dashboard;\r\n","import LocalStorage from \"./utils\";\r\n\r\nclass DragAndDrop {\r\n  localStorage = new LocalStorage();\r\n\r\n  /*controlDrop(e) {\r\n    let datos = e.dataTransfer.getData(\"userInfo\");\r\n    console.log(\"e: \", e);\r\n    const currentDragUser = this.localStorage.getLocalStorage(\"me\", \"session\");\r\n    console.log(\"userInfo: \", currentDragUser);\r\n    this.innerHTML += datos;\r\n  }*/\r\n\r\n  init() {\r\n    console.log(\"e: \", e);\r\n    /*document.querySelectorAll(\".m-room-drop-item__image\").forEach((el) => {\r\n      el.addEventListener(\r\n        \"dragenter\",\r\n        this.dragEntraContenedor.bind(this),\r\n        false\r\n      );\r\n      el.addEventListener(\r\n        \"dragover\",\r\n        this.dragSobreContenedor.bind(this),\r\n        false\r\n      );\r\n      el.addEventListener(\"dragleave\", this.dragFueraContenedor.bind(this), false);\r\n      el.addEventListener(\"drop\", this.controlDrop.bind(this), false);\r\n    });*/\r\n  }\r\n}\r\n\r\nexport default DragAndDrop;\r\n","import { EVENT_TYPES, MESSAGE_TYPES } from \"./constants\";\r\nimport LocalStorage, { getNewGameInfo } from \"./utils\";\r\n\r\nclass Game {\r\n  colors = [\"Purple\", \"Aquamarine\", \"CadetBlue\", \"DeepPink\"];\r\n  grid = [];\r\n  defeatedPlayers = [];\r\n  wrapper = document.getElementById(\"grid\");\r\n  totalCellsToWin = 0;\r\n  storage = new LocalStorage();\r\n  waittingDiv = document.querySelector(\"#roomMessage\"); // Div del mensaje de espera\r\n  roomsList;\r\n  roundTitle = document.getElementById(\"roundTitle\"); // Número del Round\r\n  pannelInfo = document.getElementById(\"roomPannelInfo\");\r\n\r\n  constructor(roomId, playerInfo, players, gameSize) {\r\n    this.player = playerInfo;\r\n    this.players = this.userToPlayerDTO(players);\r\n    this.gridSize = gameSize;\r\n    this.totalCells = gameSize * gameSize;\r\n    this.round = { turn: 1, roundNumber: 1, player: this.players[0] };\r\n    this.grid = this.generateGrid(gameSize);\r\n    this.roomId = roomId;\r\n  }\r\n\r\n  isMyTurn(round) {\r\n    return round.player.id === this.player.id;\r\n  }\r\n\r\n  getPlayers() {\r\n    return this.players;\r\n  }\r\n\r\n  // Método que calcula la nueva info del Round después de un movimiento\r\n  calculateNewRoundInfo() {\r\n    const newTurn = this.round.turn + 1;\r\n    const isTurnEnd = newTurn > this.players.length;\r\n    const newRoundTitle = isTurnEnd\r\n      ? this.round.roundNumber + 1\r\n      : this.round.roundNumber;\r\n\r\n    // Si el último jugador ha movido cambiamos el número del Round\r\n    // si no, aumentamos en 1 el turno\r\n    if (isTurnEnd) {\r\n      this.roundTitle.querySelector(\"span\").innerHTML = newRoundTitle;\r\n    }\r\n\r\n    return {\r\n      roundNumber: newRoundTitle,\r\n      turn: isTurnEnd ? 1 : newTurn,\r\n      player: isTurnEnd ? this.players[0] : this.players[newTurn - 1],\r\n    };\r\n  }\r\n\r\n  showRoomMessage(type) {\r\n    let message;\r\n    const messageDiv = document.querySelector(\"#roomMessage\");\r\n    switch (type) {\r\n      case MESSAGE_TYPES.WAITTING_TURN:\r\n        message = `Es el turno de  ${this.round.player.name}, espera a que haga su movimiento`;\r\n        break;\r\n      case MESSAGE_TYPES.HAS_LOST:\r\n        message = `Lo sentimos ${this.player.name}, te han dejado sin casillas. ¡Has perdido!`;\r\n        break;\r\n      default:\r\n        return \"\";\r\n    }\r\n    this.waittingDiv.classList.remove(\"d-none\");\r\n    const messageType = this.player.hasLost ? \"danger\" : \"info\";\r\n    const messageContentDiv = `<div class=\"alert alert-${messageType} fade show\" role=\"alert\">\r\n                <span id=\"roomMessageContent\">${message}</span>\r\n              </div>`;\r\n    messageDiv.innerHTML = messageContentDiv;\r\n  }\r\n\r\n  hideRoomMessage() {\r\n    this.waittingDiv.classList.add(\"d-none\");\r\n    this.waittingDiv.innerHTML = \"\";\r\n  }\r\n\r\n  // Método que chequea que sea el turno del jugador\r\n  // y actualiza la información del juego que viene por el localStorage\r\n  checkTurn(currentRoom) {\r\n    if (this.round.player.id !== this.player.id) {\r\n      this.showRoomMessage(MESSAGE_TYPES.WAITTING_TURN);\r\n    } else {\r\n      this.hideRoomMessage();\r\n    }\r\n\r\n    // Actualizamos juego para el jugador\r\n    const updateGame = currentRoom.game;\r\n    this.roundTitle.querySelector(\"span\").innerHTML =\r\n      updateGame.round.roundNumber;\r\n\r\n    // Iteramos sobre las celdas del grid del DOM\r\n    // las cotejamos con nuestro grid actualizado del localStorage\r\n    // Si existe un id dentro del grid que es = a el del id de la cell\r\n    // cambiamos el color de la celda\r\n    const cells = this.wrapper.querySelectorAll(\".m-game-grid__cell\");\r\n    cells.forEach((cell, index) => {\r\n      const cellId = cell.id;\r\n      if (this.grid[index].id && this.grid[index].id === cellId) {\r\n        cell.style.backgroundColor = this.grid[index].color;\r\n      }\r\n    });\r\n  }\r\n\r\n  // Método que calcula que casillas son clicables por el jugador\r\n  // de momento es en cruz\r\n  checkValidCellClick(cellObj, id) {\r\n    // row de la casilla clickada\r\n    const row = Number(cellObj.row);\r\n    // celda de la casilla clickada\r\n    const cell = Number(cellObj.cell);\r\n\r\n    // Generamos posibles celdas adjacentes que pueden ser del jugador\r\n    const nearCells = [\r\n      `cell${row + 1}-${cell}`,\r\n      `cell${row}-${cell + 1}`,\r\n      `cell${row - 1}-${cell}`,\r\n      `cell${row}-${cell - 1}`,\r\n    ];\r\n    // Inicializamos un array para guardar las celdas\r\n    // adjacentes que pertenecen al jugador\r\n    const validClick = [];\r\n\r\n    // Iteramos por el array de grid de nuestra clase Game para\r\n    // cotejar si las celdas que estan en nearCells tienen registrado al\r\n    // jugador, de modo que sabemos que son casillas en las que ha hecho click\r\n    // anteriormente\r\n    for (let i = 0; i < nearCells.length; i++) {\r\n      // buscamos dentro de nuestro registro de grid la id de celda\r\n      const targetCell = this.grid.find((cell) => cell.id === nearCells[i]);\r\n      // Si la celda existe en el gri y además está registrado a nombre del jugador\r\n      // añadimos una celda válida dentro de las posibles celdas adyacentes\r\n      if (targetCell && targetCell.playerId === id) {\r\n        validClick.push({ validCell: true });\r\n      }\r\n    }\r\n\r\n    // Retornamos un valor booleanos que nos dice si almenos una\r\n    // de las casillas adjacentes a la casilla en la que se ha hecho click\r\n    // pertenece al jugador\r\n    return validClick.some((el) => el.validCell);\r\n  }\r\n\r\n  // Método que chequea la celda que se ha clicado en el tablero\r\n  // Chequeamos que sea clicable\r\n  // Chequeamos si el jugador ha ganado\r\n  // Actualizamos el localStorage con ese clic\r\n  checkCellClick(e) {\r\n    if (!this.isMyTurn(this.round)) return;\r\n\r\n    // chequeamos a que jugador le toca\r\n    const currentPlayerTurn = this.round.player;\r\n\r\n    // sacamos la id de la celda dentro del DOM\r\n    // sacamos los data asciados al número de row y la celda\r\n    const cellId = e.target.id;\r\n    const cellObj = {\r\n      row: e.target.dataset.row,\r\n      cell: e.target.dataset.cell,\r\n    };\r\n    const cell = document.getElementById(cellId);\r\n\r\n    // comprobamos si es adjacente a la última seleccionada por el jugador\r\n    // siempre y cuando no sea el primer turno\r\n    if (this.round.roundNumber !== 1) {\r\n      let isCellFilled, isAValidCellClick;\r\n      // comprobamos si está llena\r\n      isCellFilled = cell.classList.contains(\"isFilled\");\r\n      // comprobamos si el click está en una casilla adjacente que pertenece al jugador\r\n      isAValidCellClick = this.checkValidCellClick(\r\n        cellObj,\r\n        currentPlayerTurn.id\r\n      );\r\n\r\n      if (isCellFilled || !isAValidCellClick) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Añadimos la class isFilled que no permite pulsar la casilla\r\n    cell.classList.add(\"isFilled\");\r\n    // Cambiamos la celda al color del jugador\r\n    cell.style.backgroundColor = currentPlayerTurn.color;\r\n    // Le sumamos 1 a sus casillas conquistadas\r\n    // y registramos la id de la celda como última posición\r\n    this.AddConqueredCell(currentPlayerTurn.id, cellId);\r\n\r\n    // Comprobamos que ninguno de los otros jugadores\r\n    // ha perdido.\r\n    this.checkOtherPlayerLoss(currentPlayerTurn.id);\r\n\r\n    // Comprobamos si ha ganado\r\n    if (this.totalCellsToWin === currentPlayerTurn.cellsConquered) {\r\n      console.log(`El jugador ${currentPlayerTurn.name} ha ganado!!!`);\r\n    }\r\n\r\n    if (this.players.length == 1) {\r\n      console.log(`El jugador ${this.players[0].name} ha ganado!!!`);\r\n    }\r\n\r\n    // Actualizamos información del round\r\n    this.round = this.calculateNewRoundInfo();\r\n\r\n    const newGameToStorage = getNewGameInfo(this);\r\n\r\n    // Enviamos update al storage\r\n    this.updateGame(this.getRoomsList(), newGameToStorage);\r\n    const currentRoom = this.getRoomsList().rooms.find(\r\n      (room) => room.id === this.roomId\r\n    );\r\n    this.checkTurn(currentRoom);\r\n  }\r\n\r\n  // Devuelve la key roomsList del localStorage\r\n  getRoomsList() {\r\n    return this.storage.getLocalStorage(\"roomsList\");\r\n  }\r\n\r\n  checkOtherPlayerLoss(currentPlayerId) {\r\n    let otherPlayers = this.players.filter(\r\n      (otherPlayer) => otherPlayer.id !== currentPlayerId\r\n    );\r\n    let defeated = [];\r\n    otherPlayers.forEach((player) => {\r\n      let playerHasLost = true;\r\n      let conqueredCells = this.grid.filter(\r\n        (cell) => cell.playerId === player.id\r\n      );\r\n\r\n      if (conqueredCells.length > 0) {\r\n        conqueredCells.forEach((cellObj) => {\r\n          if (this.checkValidCellClick(cellObj, null)) {\r\n            playerHasLost = false;\r\n          }\r\n        });\r\n      } else {\r\n        playerHasLost = false;\r\n      }\r\n      if (playerHasLost) {\r\n        defeated.push(player);\r\n      }\r\n    });\r\n\r\n    // Si hay jugadores que han sido eliminados\r\n    // los añadimos al state de defeatedPlayers\r\n    // enviamos evento para que se enteren que han perdido\r\n    if (defeated.length > 0) {\r\n      defeated.forEach((player) => {\r\n        this.defeatedPlayers.push(player);\r\n        this.players = this.players.filter(\r\n          (oplayer) => oplayer.id !== player.id\r\n        );\r\n        // Enviamos evento que el user ha perdido\r\n        const newGameToStorage = getNewGameInfo(this);\r\n        this.notifySomeoneHasLost(newGameToStorage);\r\n      });\r\n\r\n      this.calculateTotalCellsToWin(this.totalCells, this.players);\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  // Método que añade una casilla al total\r\n  // de casillas conquistadas del jugador\r\n  AddConqueredCell(playerId, cellId) {\r\n    this.players = this.players.map((player) => {\r\n      if (player.id === playerId) {\r\n        player.cellsConquered += 1;\r\n      }\r\n      return player;\r\n    });\r\n    this.grid.forEach((cell) => {\r\n      if (cell.id === cellId) {\r\n        cell.playerId = this.round.player.id;\r\n        cell.color = this.round.player.color;\r\n      }\r\n    });\r\n  }\r\n\r\n  defeatPlayer(player) {\r\n    this.defeatedPlayers.push(player);\r\n    this.players = this.players.filter((oplayer) => oplayer.id !== player.id);\r\n    console.log(`El jugador ${player.name} ha perdido!!!`);\r\n  }\r\n\r\n  takeOutFromGame(player) {\r\n    let is_in = this.players.find(\r\n      (current_player) => current_player.id === player.id\r\n    );\r\n    if (!!is_in) {\r\n      this.defeatPlayer(player);\r\n      this.calculateTotalCellsToWin(this.totalCells, this.players);\r\n    }\r\n  }\r\n\r\n  createDomGrid() {\r\n    const size = this.gridSize;\r\n    this.wrapper.innerHTML = \"\";\r\n    let rowCounter = 1;\r\n    let cellCounter = 1;\r\n    let cells = [];\r\n\r\n    for (let i = 1; i <= size * size; i++) {\r\n      let cellId = `cell${rowCounter}-${cellCounter}`;\r\n      let cell = document.createElement(\"div\");\r\n      cell.id = cellId;\r\n      cell.row = rowCounter;\r\n      cell.cell = cellCounter;\r\n      cell.className = `m-game-grid__cell cell-${rowCounter}-${cellCounter}`;\r\n      cell.dataset.cell = cellCounter;\r\n      cell.dataset.row = rowCounter;\r\n      cell.addEventListener(\"click\", this.checkCellClick.bind(this), false);\r\n      cells.push(cell);\r\n      cellCounter++;\r\n\r\n      // Si hay 20 celdas\r\n      if (i % size === 0) {\r\n        // Creamos contenedor de la fila\r\n        let row = document.createElement(\"div\");\r\n        row.className = \"m-game-grid__row\";\r\n\r\n        // Añadimos las 20 celdas a la fila\r\n        cells.forEach((cell, index) => {\r\n          row.appendChild(cell);\r\n        });\r\n\r\n        // Añadimos la fila al grid del HTML\r\n        this.wrapper.appendChild(row);\r\n\r\n        // Reiniciamos el array de celdas,\r\n        // el contador de celdas a 1\r\n        // y añadimos 1 al contador de filas\r\n        cells = [];\r\n        cellCounter = 1;\r\n        rowCounter++;\r\n      }\r\n\r\n      // registamos la id de la casilla en nuestro registro de grid\r\n      this.grid[i - 1] = {\r\n        id: cell.id,\r\n        row: cell.row,\r\n        cell: cell.cell,\r\n        playerId: null,\r\n        color: null,\r\n      };\r\n    }\r\n  }\r\n\r\n  createLegend(players) {\r\n    const existingPlayers = players ?? this.players;\r\n    const userLegend = existingPlayers\r\n      .map(\r\n        (player) =>\r\n          `<li><span style=\"background-color: ${player.color}\"></span><span>${player.name}</span></li>`\r\n      )\r\n      .join(\"\");\r\n    this.pannelInfo.innerHTML = `<span>Jugadores:</span> <ul>${userLegend}</ul>`;\r\n  }\r\n\r\n  // Método que inicializa el registro de grid según las dimensiones\r\n  generateGrid(gridSize) {\r\n    return [...Array(gridSize * gridSize)];\r\n  }\r\n\r\n  // Método que transforma los datos que nos llegan de los usuarios\r\n  // a datos de jugador que necesitamos para gestionar el juego\r\n  userToPlayerDTO(players) {\r\n    return players.map((player, index) => ({\r\n      id: player.id,\r\n      name: player.name,\r\n      cellsConquered: 0,\r\n      color: this.colors[index],\r\n      hasLost: false,\r\n    }));\r\n  }\r\n\r\n  // Método que calcula el total de celdas que tiene\r\n  // que rellenar un jugador para ganar\r\n  calculateTotalCellsToWin(totalCells, players) {\r\n    const numPlayers = players.length;\r\n    let totalDefeatedCells = 0;\r\n\r\n    this.defeatedPlayers.forEach((defeatyedPlayer) => {\r\n      const cellsConquered = defeatyedPlayer.cellsConquered;\r\n      totalDefeatedCells += cellsConquered;\r\n    });\r\n\r\n    this.totalCellsToWin =\r\n      Math.floor((totalCells - totalDefeatedCells) / numPlayers) + 1;\r\n  }\r\n\r\n  //Evento para notificar que alguien ha perdido\r\n  notifySomeoneHasLost(newGameInfo) {\r\n    const updateRooms = this.getRoomsList().rooms.map((room) => {\r\n      if (room.id === this.roomId) {\r\n        room.game = newGameInfo;\r\n      }\r\n      return room;\r\n    });\r\n\r\n    const roomListUpdate = {\r\n      eventType: EVENT_TYPES.SOMEONE_HAS_LOST,\r\n      roomEventId: this.roomId,\r\n      rooms: updateRooms,\r\n    };\r\n\r\n    this.storage.setLocalStorage(\"roomsList\", roomListUpdate);\r\n  }\r\n\r\n  // Método que inicializa el juego\r\n  init(isCallWithEvent) {\r\n    this.createDomGrid();\r\n    this.calculateTotalCellsToWin(this.totalCells, this.players);\r\n    this.initStorageEvents();\r\n    this.roundTitle.querySelector(\"span\").innerHTML = 1;\r\n    this.roundTitle.classList.remove(\"d-none\");\r\n    this.createLegend();\r\n\r\n    if (!this.isMyTurn(this.round)) {\r\n      this.showRoomMessage(MESSAGE_TYPES.WAITTING_TURN);\r\n    }\r\n\r\n    // Inicializamos los datos del juego partiendo del orden establecido\r\n    // por orden de conexión a la sala, que viene dado por el userRomms del localStorage\r\n    // mediante isCallWithEvent, si el juego se ha inciado por evento no lo hacemos ya que\r\n    // inicialmente ya lo ha iniciado el primero que le ha dado al botón de play\r\n    if (!isCallWithEvent) {\r\n      const initNewGameToStorage = {\r\n        defeatedPlayers: this.defeatedPlayers,\r\n        grid: this.grid,\r\n        players: this.players,\r\n        round: this.round,\r\n        totalCellsToWin: this.totalCellsToWin,\r\n      };\r\n\r\n      this.updateGame(this.getRoomsList(), initNewGameToStorage);\r\n    }\r\n  }\r\n\r\n  // Método que actualiza el localStorage del juego\r\n  // y añade un evento del tipo update para que el listener del storage\r\n  // reaccione en el resto de tabs de jugador\r\n  updateGame(roomsList, newGameInfo) {\r\n    const updateRooms = roomsList.rooms.map((room) => {\r\n      if (room.id === this.roomId) {\r\n        room.game = newGameInfo;\r\n      }\r\n      return room;\r\n    });\r\n\r\n    const roomListUpdate = {\r\n      eventType: EVENT_TYPES.UPDATE_GAME,\r\n      roomEventId: this.roomId,\r\n      rooms: updateRooms,\r\n    };\r\n\r\n    this.storage.setLocalStorage(\"roomsList\", roomListUpdate);\r\n  }\r\n\r\n  // Método que añade el evento storage al juego\r\n  initStorageEvents() {\r\n    window.addEventListener(\"storage\", (e) => {\r\n      // por cada sala se lanza este evento\r\n      if (e.key === \"roomsList\") {\r\n        const roomsList = JSON.parse(e.newValue);\r\n\r\n        switch (roomsList.eventType) {\r\n          case EVENT_TYPES.UPDATE_GAME:\r\n            !this.player.hasLost && this.handleUpdateEventGame(roomsList);\r\n            break;\r\n          case EVENT_TYPES.SOMEONE_HAS_LOST:\r\n            !this.player.hasLost && this.handleSomeoneHasLostEvent(roomsList);\r\n            break;\r\n          default:\r\n            return;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  // Recibe el evento update y cambia la info de los demás jugadores\r\n  // que estan conectados a la partida y aún no es su turno\r\n  handleUpdateEventGame(roomsList) {\r\n    console.log(\"update game from event\");\r\n    // Si la sala no es la que tiene el evento no hacemos nada\r\n    if (roomsList.roomEventId !== this.roomId) return;\r\n\r\n    const currentRoom = roomsList.rooms.find(\r\n      (room) => room.id === roomsList.roomEventId\r\n    );\r\n\r\n    // Actualizamos grid de la clase\r\n    this.grid = currentRoom.game.grid;\r\n    this.round = currentRoom.game.round;\r\n    this.totalCellsToWin = currentRoom.game.totalCellsToWin;\r\n    this.players = currentRoom.game.players;\r\n\r\n    // Chequeamos el turno del jugador\r\n    this.checkTurn(currentRoom);\r\n  }\r\n\r\n  // Recibe el evento que alguien ha perdido y lo notifica a aquella id\r\n  // de usuariso que corresponda\r\n  handleSomeoneHasLostEvent(roomsList) {\r\n    // Si la sala no es la que tiene el evento no hacemos nada\r\n    if (roomsList.roomEventId !== this.roomId) return;\r\n\r\n    const currentRoom = roomsList.rooms.find(\r\n      (room) => roomsList.roomEventId === room.id\r\n    );\r\n\r\n    // Sacamos las id que hay dentro de los array de jugadores que han perdido\r\n    const defeatedPlayersId = currentRoom.game.defeatedPlayers.map(\r\n      (defeatedPlayer) => defeatedPlayer.id\r\n    );\r\n\r\n    if (defeatedPlayersId.includes(this.player.id)) {\r\n      this.showRoomMessage(MESSAGE_TYPES.HAS_LOST);\r\n      this.player.hasLost = true;\r\n      this.createLegend(currentRoom.game.players);\r\n    }\r\n  }\r\n}\r\n\r\nexport default Game;\r\n","import LocalStorage from \"./utils\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\n\r\nclass Login {\r\n  fields = {};\r\n  errors = {};\r\n  storage = new LocalStorage();\r\n\r\n  constructor(loginFields) {\r\n    this.form = document.getElementById(loginFields.formId);\r\n    this.emailInput = document.getElementById(loginFields.emailId);\r\n    this.passwordInput = document.getElementById(loginFields.passwordId);\r\n    this.registerSubmitBtn = document.getElementById(loginFields.submtBtn);\r\n  }\r\n\r\n  validateEmail(name, element, value) {\r\n    let message, isValid;\r\n\r\n    if (value === \"\") {\r\n      message = \"El email no puede estar vacío\";\r\n      isValid = false;\r\n    }\r\n\r\n    if (value !== \"\") {\r\n      const regex =\r\n        /^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/;\r\n      isValid = regex.test(value);\r\n      message = isValid ? \"\" : \"El email no es válido\";\r\n    }\r\n\r\n    if (isValid) {\r\n      delete this.errors[name];\r\n      element.classList.remove(\"is-invalid\");\r\n      document.getElementById(`${element.id}_error`).innerHTML = \"\";\r\n      this.fields[name].value = value;\r\n      return;\r\n    } else {\r\n      this.fields[name].value = \"\";\r\n    }\r\n\r\n    this.errors[name] = {\r\n      element: element,\r\n      message,\r\n    };\r\n  }\r\n\r\n  validatePassword(name, element, value) {\r\n    const isValid = value !== \"\";\r\n    const message = isValid ? \"\" : \"El password no puede estar vacío\";\r\n\r\n    if (isValid) {\r\n      delete this.errors[name];\r\n      element.classList.remove(\"is-invalid\");\r\n      document.getElementById(`${element.id}_error`).innerHTML = \"\";\r\n      this.fields[name].value = value;\r\n      return;\r\n    } else {\r\n      this.fields[name].value = \"\";\r\n    }\r\n\r\n    this.errors[name] = {\r\n      element: element,\r\n      message,\r\n    };\r\n  }\r\n\r\n  registerLoginFields() {\r\n    const requiredFields = [\r\n      {\r\n        name: \"emailInput\",\r\n        element: this.emailInput,\r\n        validate: this.validateEmail.bind(this),\r\n      },\r\n      {\r\n        name: \"passwordInput\",\r\n        element: this.passwordInput,\r\n        validate: this.validatePassword.bind(this),\r\n      },\r\n    ];\r\n    requiredFields.forEach((field) => {\r\n      this.fields[field.name] = {\r\n        name: field.name,\r\n        validate: field.validate,\r\n        element: field.element,\r\n        value: \"\",\r\n      };\r\n    });\r\n  }\r\n\r\n  assignListeners() {\r\n    this.form.addEventListener(\"submit\", this.send.bind(this));\r\n  }\r\n\r\n  init() {\r\n    this.redirectToRooms();\r\n    this.registerLoginFields();\r\n    this.assignListeners();\r\n  }\r\n\r\n  loginUser(data) {\r\n    const allUSers = this.storage.getLocalStorage(\"users\");\r\n    const newUser = data;\r\n    const user = allUSers?.find((user) => user.email === newUser.email);\r\n    if (!user) {\r\n      this.showErrorMessage(\"No existe nadie con este email\");\r\n      return;\r\n    }\r\n    const passWordIsValid = allUSers.find(\r\n      (user) => user.password === newUser.password\r\n    );\r\n    if (!passWordIsValid) {\r\n      this.showErrorMessage(\"La contraseña no es válida\");\r\n      return;\r\n    }\r\n\r\n    // Aqui va la lógica para poner al \"user\" (línea 95) dentro de los usuarios conectados\r\n    this.storage.setLocalStorage(\"me\", user, \"session\");\r\n\r\n    //!Temporal\r\n    const connectedUsers = this.storage.getLocalStorage(\"connectedUsers\");\r\n    if (!connectedUsers) {\r\n      this.storage.setLocalStorage(\"connectedUsers\", [user]);\r\n    } else {\r\n      const existConnectedUser = connectedUsers.find(\r\n        (connectedUser) => connectedUser.id === user.id\r\n      );\r\n      if (!existConnectedUser) {\r\n        connectedUsers.push(user);\r\n        this.storage.setLocalStorage(\"connectedUsers\", connectedUsers);\r\n      }\r\n    }\r\n\r\n    // También se tiene que redirigir al usuario a la ruta /rooms\r\n    window.location.href = \"/rooms\";\r\n  }\r\n\r\n  showErrorMessage(message) {\r\n    const messageElement = document.getElementById(\"errorMessage\");\r\n    messageElement.innerHTML = message;\r\n    messageElement.classList.remove(\"d-none\");\r\n  }\r\n\r\n  redirectToRooms() {\r\n    let user = this.storage.getLocalStorage(\"me\", \"session\");\r\n    if (user) {\r\n      window.location.href = \"/rooms\";\r\n    }\r\n  }\r\n\r\n  send(e) {\r\n    e.preventDefault();\r\n    const fields = this.fields;\r\n\r\n    const errorMessageElement = document.getElementById(\"errorMessage\");\r\n    errorMessageElement.classList.add(\"d-none\");\r\n\r\n    Object.keys(fields).forEach((field) => {\r\n      this.fields[field].validate(\r\n        fields[field].name,\r\n        fields[field].element,\r\n        fields[field].element.value\r\n      );\r\n    });\r\n\r\n    const existErrors = Object.keys(this.errors).length !== 0;\r\n\r\n    if (existErrors) {\r\n      Object.keys(this.errors).forEach((error) => {\r\n        const inputElement = this.errors[error].element;\r\n        const msgErrorElement = `${inputElement.id}_error`;\r\n        inputElement.classList.add(\"is-invalid\");\r\n        document.getElementById(msgErrorElement).innerHTML =\r\n          this.errors[error].message;\r\n      });\r\n      return;\r\n    }\r\n\r\n    const data = {\r\n      email: this.fields.emailInput.value,\r\n      password: this.fields.passwordInput.value,\r\n    };\r\n\r\n    // Método para enviar la información al localStorage, al apartado de usuaros conectados\r\n    this.loginUser(data);\r\n  }\r\n}\r\n\r\nexport default Login;\r\n","import LocalStorage from \"./utils\";\r\nimport { v4 as uuidv4 } from \"uuid\";\r\n\r\nclass Register {\r\n  fields = {};\r\n  errors = {};\r\n  local = new LocalStorage();\r\n\r\n  constructor(registerFields) {\r\n    this.form = document.getElementById(registerFields.formId);\r\n    this.nameInput = document.getElementById(registerFields.nameId);\r\n    this.emailInput = document.getElementById(registerFields.emailId);\r\n    this.passwordInput = document.getElementById(registerFields.passwordId);\r\n    this.favouriteRoom = document.getElementById(\r\n      registerFields.favouriteRoomId\r\n    );\r\n    this.avatarWrapper = document.getElementById(\r\n      registerFields.avatarWrapperId\r\n    );\r\n    this.registerSubmitBtn = document.getElementById(registerFields.submtBtn);\r\n  }\r\n\r\n  onSelectAvatar(e) {\r\n    const avatarId = e.target.id;\r\n    const avatarDiv = document.getElementById(avatarId);\r\n    this.selectAvatar(avatarDiv);\r\n  }\r\n\r\n  selectAvatar(selected) {\r\n    const avatars = this.avatarWrapper.querySelectorAll(\".a-avatar\");\r\n    avatars.forEach((avatar) => {\r\n      avatar.classList.remove(\"active\");\r\n    });\r\n\r\n    selected.classList.add(\"active\");\r\n  }\r\n\r\n  assignListeners() {\r\n    const avatars = this.avatarWrapper.querySelectorAll(\".a-avatar\");\r\n    avatars.forEach((avatar) => {\r\n      avatar.addEventListener(\"click\", this.onSelectAvatar.bind(this));\r\n    });\r\n\r\n    this.form.addEventListener(\"submit\", this.send.bind(this));\r\n  }\r\n\r\n  resetForm() {\r\n    for (let field in this.fields) {\r\n      const fieldEl = this.fields[field];\r\n      fieldEl.value = \"\";\r\n      if (fieldEl.name === \"favouriteRoom\") {\r\n        fieldEl.element.value = \"0\";\r\n      } else {\r\n        fieldEl.element.value = \"\";\r\n      }\r\n    }\r\n\r\n    const defaultAvatar = document.getElementById(\"avatar1\");\r\n    this.selectAvatar(defaultAvatar);\r\n  }\r\n\r\n  validateName(name, element, value) {\r\n    const isValid = value !== \"\";\r\n    const message = isValid ? \"\" : \"El nombre no puede estar vacío\";\r\n\r\n    if (isValid) {\r\n      delete this.errors[name];\r\n      element.classList.remove(\"is-invalid\");\r\n      document.getElementById(`${element.id}_error`).innerHTML = \"\";\r\n      this.fields[name].value = value;\r\n      return;\r\n    } else {\r\n      this.fields[name].value = \"\";\r\n    }\r\n\r\n    this.errors[name] = {\r\n      element: element,\r\n      message,\r\n    };\r\n  }\r\n\r\n  validateEmail(name, element, value) {\r\n    let message, isValid;\r\n\r\n    if (value === \"\") {\r\n      message = \"El email no puede estar vacío\";\r\n      isValid = false;\r\n    }\r\n\r\n    if (value !== \"\") {\r\n      const regex =\r\n        /^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/;\r\n      isValid = regex.test(value);\r\n      message = isValid ? \"\" : \"El email no es válido\";\r\n    }\r\n\r\n    if (isValid) {\r\n      delete this.errors[name];\r\n      element.classList.remove(\"is-invalid\");\r\n      document.getElementById(`${element.id}_error`).innerHTML = \"\";\r\n      this.fields[name].value = value;\r\n      return;\r\n    } else {\r\n      this.fields[name].value = \"\";\r\n    }\r\n\r\n    this.errors[name] = {\r\n      element: element,\r\n      message,\r\n    };\r\n  }\r\n\r\n  validatePassword(name, element, value) {\r\n    const isValid = value !== \"\";\r\n    const message = isValid ? \"\" : \"El password no puede estar vacío\";\r\n\r\n    if (isValid) {\r\n      delete this.errors[name];\r\n      element.classList.remove(\"is-invalid\");\r\n      document.getElementById(`${element.id}_error`).innerHTML = \"\";\r\n      this.fields[name].value = value;\r\n      return;\r\n    } else {\r\n      this.fields[name].value = \"\";\r\n    }\r\n\r\n    this.errors[name] = {\r\n      element: element,\r\n      message,\r\n    };\r\n  }\r\n\r\n  validateFavouriteRoom(name, element, value) {\r\n    const isValid = value !== \"0\";\r\n    const message = isValid ? \"\" : \"Debes seleccionar una sala\";\r\n\r\n    if (isValid) {\r\n      delete this.errors[name];\r\n      element.classList.remove(\"is-invalid\");\r\n      document.getElementById(`${element.id}_error`).innerHTML = \"\";\r\n      this.fields[name].value = value;\r\n      return;\r\n    } else {\r\n      this.fields[name].value = \"\";\r\n    }\r\n\r\n    this.errors[name] = {\r\n      element: element,\r\n      message,\r\n    };\r\n  }\r\n\r\n  registerFields() {\r\n    const requiredFields = [\r\n      {\r\n        name: \"nameInput\",\r\n        element: this.nameInput,\r\n        validate: this.validateName.bind(this),\r\n      },\r\n      {\r\n        name: \"emailInput\",\r\n        element: this.emailInput,\r\n        validate: this.validateEmail.bind(this),\r\n      },\r\n      {\r\n        name: \"passwordInput\",\r\n        element: this.passwordInput,\r\n        validate: this.validatePassword.bind(this),\r\n      },\r\n      {\r\n        name: \"favouriteRoom\",\r\n        element: this.favouriteRoom,\r\n        validate: this.validateFavouriteRoom.bind(this),\r\n      },\r\n    ];\r\n    requiredFields.forEach((field) => {\r\n      this.fields[field.name] = {\r\n        name: field.name,\r\n        validate: field.validate,\r\n        element: field.element,\r\n        value: \"\",\r\n      };\r\n    });\r\n  }\r\n\r\n  init() {\r\n    this.redirectToRooms();\r\n    this.assignListeners();\r\n    this.registerFields();\r\n  }\r\n\r\n  saveUser(data) {\r\n    const allUSers = this.local.getLocalStorage(\"users\");\r\n    const newUser = data;\r\n\r\n    if (!allUSers || allUSers.length === 0) {\r\n      this.local.setLocalStorage(\"users\", [newUser]);\r\n      this.resetForm();\r\n      this.showSuccesMessage();\r\n      return;\r\n    }\r\n\r\n    const existUSer = allUSers.find((user) => user.email === newUser.email);\r\n    if (existUSer) {\r\n      this.showErrorMessage(\"Ya existe un usuario con este email\");\r\n      return;\r\n    }\r\n\r\n    allUSers.push(newUser);\r\n    this.local.setLocalStorage(\"users\", allUSers);\r\n    this.resetForm();\r\n    this.showSuccesMessage();\r\n  }\r\n\r\n  showErrorMessage(message) {\r\n    const messageElement = document.getElementById(\"errorMessage\");\r\n    messageElement.innerHTML = message;\r\n    messageElement.classList.remove(\"d-none\");\r\n  }\r\n\r\n  showSuccesMessage() {\r\n    const message = \"Tu usuario se ha registrado correctamente.\";\r\n    const messageElement = document.getElementById(\"successMessage\");\r\n    const loginButton = document.getElementById(\"successButton\");\r\n    const submitButton = document.getElementById(\"submitButton\");\r\n    messageElement.innerHTML = message;\r\n    messageElement.classList.remove(\"d-none\");\r\n    loginButton.classList.remove(\"d-none\");\r\n    submitButton.classList.add(\"d-none\");\r\n\r\n    setTimeout(() => {\r\n      messageElement.classList.add(\"d-none\");\r\n      submitButton.classList.remove(\"d-none\");\r\n    }, 2000);\r\n  }\r\n\r\n  send(e) {\r\n    e.preventDefault();\r\n    const fields = this.fields;\r\n\r\n    const errorMessageElement = document.getElementById(\"errorMessage\");\r\n    errorMessageElement.classList.add(\"d-none\");\r\n\r\n    Object.keys(fields).forEach((field) => {\r\n      this.fields[field].validate(\r\n        fields[field].name,\r\n        fields[field].element,\r\n        fields[field].element.value\r\n      );\r\n    });\r\n\r\n    const existErrors = Object.keys(this.errors).length !== 0;\r\n\r\n    if (existErrors) {\r\n      Object.keys(this.errors).forEach((error) => {\r\n        const inputElement = this.errors[error].element;\r\n        const msgErrorElement = `${inputElement.id}_error`;\r\n        inputElement.classList.add(\"is-invalid\");\r\n        document.getElementById(msgErrorElement).innerHTML =\r\n          this.errors[error].message;\r\n      });\r\n      return;\r\n    }\r\n\r\n    const data = {\r\n      id: uuidv4(),\r\n      name: this.fields.nameInput.value,\r\n      email: this.fields.emailInput.value,\r\n      password: this.fields.passwordInput.value,\r\n      avatar: `mod${this.avatarWrapper.querySelector(\".active\").dataset.mod}`,\r\n      favouriteRoom: this.fields.favouriteRoom.value,\r\n      color: `mod${this.avatarWrapper.querySelector(\".active\").dataset.mod}`,\r\n    };\r\n\r\n    // Evento para enviar la información al localStorage, al apartado de usuaros registrados\r\n    this.saveUser(data);\r\n  }\r\n\r\n  redirectToRooms(){\r\n    let user = this.local.getLocalStorage(\"me\", \"session\");\r\n    if(user){\r\n      window.location.href = \"/rooms\";\r\n    }\r\n  }\r\n}\r\n\r\nexport default Register;\r\n","import { EVENT_TYPES, MESSAGE_TYPES } from \"./constants\";\r\nimport LocalStorage from \"./utils\";\r\nimport Game from \"./Game\";\r\nimport DragAndDrop from \"./DragAndDrop\";\r\nclass Room {\r\n  capacity = 4;\r\n  isOpen = true;\r\n  players = [];\r\n  roomBox = \"\";\r\n  game = \"\";\r\n  storage = new LocalStorage();\r\n  playButtonDiv = document.getElementById(\"playButton\");\r\n  //dragAndDrop = new DragAndDrop();\r\n  roomBox;\r\n  currentAvatar;\r\n\r\n  constructor(id, name, capacity) {\r\n    this.id = id;\r\n    this.name = name;\r\n    this.capacity = capacity;\r\n    this.roomBox = document.querySelector(`#${id} .m-room-drop-item__image`);\r\n  }\r\n\r\n  initDragListeners() {\r\n    //console.log(\"caja: \", this.roomBox);\r\n    this.roomBox.addEventListener(\"drop\", this.onDropPlayer.bind(this));\r\n    this.roomBox.addEventListener(\"dragover\", this.dragSobreContenedor.bind(this));\r\n    this.roomBox.addEventListener(\"dragleave\", this.dragSaleContenedor.bind(this));\r\n  }\r\n\r\n  dragSaleContenedor(e) {\r\n    //console.log(\"dragSaleContenedor e: \", e);\r\n    //this.classList.remove(\"over\");\r\n  }\r\n\r\n  dragSobreContenedor(e) {\r\n    e.preventDefault();\r\n    //console.log(\"dragSobreContenedor e: \", e);\r\n    //this.classList.add(\"over\");\r\n    //return false;\r\n  }\r\n\r\n  onDropPlayer(e) {\r\n    //console.log(e);\r\n    const dragUSer = this.storage.getLocalStorage(\"me\", \"session\");\r\n    const avatarMobile = document.getElementById(e.dataTransfer.getData(\"userAvatar\"));\r\n    console.log(avatarMobile);\r\n    console.log(avatarMobile.parentNode);\r\n    console.log(avatarMobile.parentElement);\r\n    this.currentAvatar = avatarMobile;\r\n    console.log(this.currentAvatar);\r\n    this.roomBox.innerHTML =this.currentAvatar.outerHTML;\r\n    //avatarMobile.innerHTML = \"\";\r\n\r\n\r\n    \r\n    avatarMobile.parentNode.removeChild(avatarMobile);\r\n    //this.classList.remove('over');\r\n\r\n    // if (this.players.length === this.capacity) {\r\n    //   this.isOpen = false;\r\n    //   this.disableRoom(this.id);\r\n    //   console.log(\"sala llena!\");\r\n    //   return;\r\n    // }\r\n\r\n    // if (this.players.length > this.capacity || !this.isOpen) {\r\n    //   console.log(\"La sala no acepta más jugadores\");\r\n    //   return;\r\n    // }\r\n\r\n    this.addToRoom(dragUSer);\r\n  }\r\n\r\n  addToRoom(user) {\r\n    // Creamos jugador que recoge los datos del usuario arrastrado\r\n\r\n    console.log(\"user:\", user);\r\n\r\n    const draggedPlayer = {\r\n      name: user.name,\r\n      avatar: user.avatar,\r\n      id: user.id,\r\n    };\r\n\r\n    const rooms = this.storage.getLocalStorage(\"roomsList\").rooms;\r\n    const currentRoom = rooms.find((room) => room.id === this.id);\r\n    const restUsers = currentRoom.usersRoom.filter(\r\n      (userRoom) => userRoom.id !== draggedPlayer.id\r\n    );\r\n\r\n    // Si no existen usuarios en la sala\r\n    if (currentRoom.usersRoom.length === 0) {\r\n      currentRoom.usersRoom.push(draggedPlayer);\r\n      this.updatePlayers(currentRoom.usersRoom);\r\n    } else {\r\n      // Si no existe el usuario y ya hay usuarios en la sala\r\n      currentRoom.usersRoom = [...restUsers, draggedPlayer];\r\n      this.updatePlayers(currentRoom.usersRoom);\r\n    }\r\n\r\n    // Añadimos players a la room\r\n    this.players = currentRoom.usersRoom;\r\n\r\n    // Añadimos rooms actualizado al localStorage\r\n    const updateRooms = rooms.map((room) => {\r\n      if (room.id === this.id) {\r\n        room.usersRoom = currentRoom.usersRoom;\r\n      }\r\n      return room;\r\n    });\r\n    const updateRoomsList = {\r\n      eventType: EVENT_TYPES.ADD_USER_TO_ROOM,\r\n      roomEventId: this.id,\r\n      rooms: updateRooms,\r\n    };\r\n\r\n    this.storage.setLocalStorage(\"roomsList\", updateRoomsList);\r\n\r\n    // Mostramos panel superior sala\r\n    const gameTopPannelDiv = document.getElementById(\"gameTopPannel\");\r\n    gameTopPannelDiv.classList.remove(\"d-none\");\r\n    setTimeout(() => gameTopPannelDiv.classList.add(\"has-players\"), 1000);\r\n    gameTopPannelDiv.querySelector(\r\n      \".m-game__title strong\"\r\n    ).innerHTML = `${this.name}`;\r\n  }\r\n\r\n  updatePlayers(usersRoom) {\r\n    const roomBoxDiv = document.getElementById(this.id);\r\n    roomBoxDiv.querySelector(\".m-room-drop-item__total span\").innerHTML =\r\n      usersRoom.length;\r\n\r\n    // Actualizamos listado de los usarios conectados en el tablero\r\n    const listConnectedUSers = document.querySelector(\r\n      \"#roomConnectedMessage ul\"\r\n    );\r\n    const connectedUsers = usersRoom.map((user) => `<li>${user.name}</li>`);\r\n    listConnectedUSers.innerHTML = connectedUsers.join(\"\");\r\n\r\n    // Mostrar posibilidad de empezar a jugar\r\n    if (usersRoom.length > 1) {\r\n      this.renderPlayBtn();\r\n    }\r\n  }\r\n\r\n  showRoomMessage(type, user) {\r\n    let message;\r\n    const messageDiv = document.querySelector(\"#roomMessage\");\r\n    switch (type) {\r\n      case MESSAGE_TYPES.CONNECTED_TO_ROOM:\r\n        message = `El usuario ${user.name} se ha conectado a esta sala`;\r\n        break;\r\n      default:\r\n        return \"\";\r\n    }\r\n\r\n    const messageContentDiv = `<div class=\"alert alert-info alert-dismissible fade show\" role=\"alert\">\r\n                <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\" aria-label=\"Close\"></button>\r\n                <span id=\"roomMessageContent\">${message}</span>\r\n              </div>`;\r\n    messageDiv.innerHTML = messageContentDiv;\r\n  }\r\n\r\n  disableRoom(id) {\r\n    const roomDivElement = document.getElementById(id);\r\n    roomDivElement.classList.add(\"isFull\");\r\n\r\n    // quitamos mensaje conectados del panel de juego\r\n    document.getElementById(\"roomConnectedMessage\").innerHTML = \"\";\r\n  }\r\n\r\n  takeOutFromRoom(player) {\r\n    let is_in = this.players.find(\r\n      (room_player) => room_player.id === player.id\r\n    );\r\n    if (!!is_in) {\r\n      this.game.takeOutFromGame(player);\r\n      //this.players = this.players.filter((room_player)=> room_player.id !== player.id);\r\n    }\r\n  }\r\n\r\n  initStorageEvents() {\r\n    window.addEventListener(\"storage\", (e) => {\r\n      // por cada sala se lanza este evento\r\n      if (e.key === \"roomsList\") {\r\n        const roomsList = JSON.parse(e.newValue);\r\n\r\n        switch (roomsList.eventType) {\r\n          case EVENT_TYPES.ADD_USER_TO_ROOM:\r\n            this.handleEventAddUser(roomsList);\r\n            break;\r\n          case EVENT_TYPES.PLAY_GAME:\r\n            this.handleEventPlayGame(roomsList);\r\n            break;\r\n          default:\r\n            return;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  handleEventAddUser(roomsList) {\r\n    // Si la sala no es la que tiene el evento no hacemos nada\r\n    if (roomsList.roomEventId !== this.id) return;\r\n\r\n    const currentEventRoom = roomsList.rooms.find(\r\n      (room) => room.id === roomsList.roomEventId\r\n    );\r\n\r\n    // Actualizamos la información relacionada con el comienzo del juego en los otros jugadores\r\n    // caja de sala, mensaje de usuarios conectados en la sala\r\n    this.updatePlayers(currentEventRoom.usersRoom);\r\n  }\r\n\r\n  handleEventPlayGame(roomsList) {\r\n    // Si la sala no es la que tiene el evento no hacemos nada\r\n    if (roomsList.roomEventId !== this.id) return;\r\n    const currentRoom = roomsList.rooms.find(\r\n      (room) => room.id === roomsList.roomEventId\r\n    );\r\n    this.initGame(currentRoom.usersRoom, true);\r\n  }\r\n\r\n  renderPlayBtn() {\r\n    this.playButtonDiv.innerHTML = `<button class=\"btn btn-primary btn-lg btn-rounded px-4\" type=\"button\">Empezar a jugar!</button>`;\r\n    this.playButtonDiv.addEventListener(\"click\", this.playGame.bind(this));\r\n  }\r\n\r\n  playGame() {\r\n    const rooms = this.storage.getLocalStorage(\"roomsList\").rooms;\r\n    const updateRoomsStorage = rooms.map((room) => {\r\n      if (room.id === this.id) {\r\n        room.isOpen = false;\r\n      }\r\n      return room;\r\n    });\r\n\r\n    this.storage.setLocalStorage(\"roomsList\", {\r\n      eventType: EVENT_TYPES.PLAY_GAME,\r\n      roomEventId: this.id,\r\n      rooms: updateRoomsStorage,\r\n    });\r\n\r\n    const currentRoom = rooms.find((room) => room.id === this.id);\r\n    this.initGame(currentRoom.usersRoom);\r\n  }\r\n\r\n  prepareGame() {\r\n    // Quitamos botón de play\r\n    this.playButtonDiv.innerHTML = \"\";\r\n\r\n    // seteamos la room a close\r\n    this.isOpen = false;\r\n\r\n    // deshabilitamos sala\r\n    this.disableRoom(this.id);\r\n  }\r\n\r\n  initGame(players, isCallWithEvent = false) {\r\n    this.prepareGame(players);\r\n    // Inicializamos juego\r\n    const gridSize = 20;\r\n    const currentPlayerInfo = this.storage.getLocalStorage(\"me\", \"session\");\r\n    this.game = new Game(this.id, currentPlayerInfo, players, gridSize);\r\n    this.game.init(isCallWithEvent);\r\n  }\r\n}\r\n\r\nexport default Room;\r\n","export const MESSAGE_TYPES = {\r\n  CONNECTED_TO_ROOM: \"CONNECTED_TO_ROOM\",\r\n  DISCONNECTED_FROM_ROOM: \"DISCONNECTED_FROM_ROOM\",\r\n  WAITTING_TURN: \"WAITTING_TURN\",\r\n  HAS_LOST: \"HAS_LOST\",\r\n};\r\n\r\nexport const EVENT_TYPES = {\r\n  ADD_USER_TO_ROOM: \"ADD_USER_TO_ROOM\",\r\n  PLAY_GAME: \"PLAY_GAME\",\r\n  UPDATE_GAME: \"UPDATE_GAME\",\r\n  SOMEONE_HAS_LOST: \"SOMEONE_HAS_LOST\",\r\n};\r\n","export default class LocalStorage {\r\n  localStorage = window.localStorage;\r\n  sessionStorage = window.sessionStorage;\r\n\r\n  setLocalStorage(key, data, type) {\r\n    const dataToLocaltorage = JSON.stringify(data);\r\n    if (type === \"session\") {\r\n      this.sessionStorage.setItem(key, dataToLocaltorage);\r\n    } else {\r\n      this.localStorage.setItem(key, dataToLocaltorage);\r\n    }\r\n  }\r\n\r\n  getLocalStorage(key, type) {\r\n    let data;\r\n    if (type === \"session\") {\r\n      data = this.sessionStorage.getItem(key);\r\n    } else {\r\n      data = this.localStorage.getItem(key);\r\n    }\r\n\r\n    return JSON.parse(data);\r\n  }\r\n}\r\n\r\nexport const getNewGameInfo = (context) => {\r\n  return {\r\n    defeatedPlayers: context.defeatedPlayers,\r\n    grid: context.grid,\r\n    players: context.players,\r\n    round: context.round,\r\n    totalCellsToWin: context.totalCellsToWin,\r\n  };\r\n};\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// extracted by mini-css-extract-plugin\nexport {};","import Game from \"./Game\";\r\nimport Room from \"./Room\";\r\nimport Dashboard from \"./DashBoard\";\r\nimport Register from \"./Register\";\r\nimport Login from \"./Login\";\r\n\r\nexport { Game, Room, Dashboard, Register, Login };\r\n"],"names":[],"sourceRoot":""}