{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;;;AAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6CAAI,gBAAgB,MAAM;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA,4BAA4B,UAAU;AACtC,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iEAAe,SAAS;;;;;;;;;;;;;;ACnCxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM,GAAG,KAAK;AAC3B,aAAa,IAAI,GAAG,OAAO;AAC3B,aAAa,MAAM,GAAG,KAAK;AAC3B,aAAa,IAAI,GAAG,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,iBAAiB;AACjB,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC,2BAA2B,YAAY,IAAI,aAAa;AACxD;AACA;AACA;AACA;AACA,iDAAiD,WAAW,GAAG,YAAY;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,6HAA6H;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,IAAI;;;;;;;;;;;;;;AC7QnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,MAAM;;;;;;;;;;;;;;ACpBrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,IAAI;;;;;;UC9DnB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNA;;;;;;;;;;;;;;;;;;;;ACA0B;AACI;AACJ;AACU;AACpC","sources":["webpack://Conquer/./src/js/DashBoard.js","webpack://Conquer/./src/js/Game.js","webpack://Conquer/./src/js/Player.js","webpack://Conquer/./src/js/Room.js","webpack://Conquer/webpack/bootstrap","webpack://Conquer/webpack/runtime/define property getters","webpack://Conquer/webpack/runtime/hasOwnProperty shorthand","webpack://Conquer/webpack/runtime/make namespace object","webpack://Conquer/./src/sass/style.scss?3ac4","webpack://Conquer/./src/js/index.js"],"sourcesContent":["import Room from \"./Room\";\r\n\r\nclass Dashboard{\r\n  rooms = [];\r\n\r\n  constructor(initData){\r\n    this.boxRooms = initData.boxRooms;\r\n  }\r\n\r\n  init(){\r\n    this.generateRooms();\r\n  }\r\n\r\n  generateRooms(){\r\n    this.boxRooms.forEach((box, index) => {\r\n      // Generamos las instancias de las salas\r\n      this.rooms[index] = new Room(box.id, `Room${index}`, 4);\r\n\r\n      const boxDiv = document.getElementById(box.id);\r\n\r\n      // Añadir evento en alguna parte del box para cuando se hace drag&drop\r\n      // Y que conecte con un método de la instancia de room\r\n\r\n      // Añadir clase para pintar caja\r\n      boxDiv.classList.add(`room${index+1}`);\r\n      // Añadir títulos\r\n      const title = `Room ${index + 1}`;\r\n      const boxDivHeader = document.querySelector(`#${box.id} .m-room-drop-item__header h3`);\r\n      boxDivHeader.innerHTML = title;\r\n\r\n\r\n    })\r\n  }\r\n}\r\n\r\nexport default Dashboard;","class Game\r\n{\r\n  colors = [ 'red', 'blue', 'green', 'brown' ];\r\n  grid = []\r\n  defeatedPlayers = [];\r\n  wrapper = \"\";\r\n  totalCellsToWin = 0;\r\n\r\n  constructor (\r\n    wrapper,\r\n    players,\r\n    gameSize\r\n  )\r\n  {\r\n    this.players = this.buildToGamePlayers( players );\r\n    this.gridSize = gameSize;\r\n    this.totalCells = gameSize * gameSize;\r\n    this.round = { turn: 1, roundNumber: 1, player: this.players[ 0 ] }\r\n    this.grid = this.generateGrid(gameSize);\r\n    this.wrapper = wrapper;\r\n  }\r\n\r\n  getPlayers ()\r\n  {\r\n    console.log( 'players: ', this.players );\r\n  }\r\n\r\n  getRoundInfo(){\r\n    const newTurn = this.round.turn + 1;\r\n    const isTurnEnd = newTurn > this.players.length;\r\n    const newRoundTitle = isTurnEnd ? this.round.roundNumber + 1 : this.round.roundNumber;\r\n\r\n    if(isTurnEnd){\r\n      const rountDivSection = document.querySelector('#roundTitle h3');\r\n      rountDivSection.innerHTML = `Round ${newRoundTitle}`\r\n    }\r\n\r\n    return {\r\n      roundNumber: newRoundTitle,\r\n      turn: isTurnEnd ? 1 : newTurn,\r\n      player: isTurnEnd ? this.players[0] : this.players[ newTurn - 1]\r\n    }\r\n  }\r\n\r\n  checkTurn ()\r\n  {\r\n    // Me descargo los updates del juego\r\n\r\n    // Seteo las propiedades del juego con esa info\r\n    this.round = this.getRoundInfo();\r\n  }\r\n\r\n  checkValidCellClick (cellObj, id){\r\n    // row de la casilla clickada\r\n    const row = Number(cellObj.row);\r\n    // celda de la casilla clickada\r\n    const cell = Number(cellObj.cell);\r\n\r\n    // Generamos posibles celdas adjacentes que pueden ser del jugador\r\n    const nearCells = [\r\n      `cell${row+1}-${cell}`,\r\n      `cell${row}-${cell+1}`,\r\n      `cell${row-1}-${cell}`,\r\n      `cell${row}-${cell-1}`\r\n    ]\r\n    // Inicializamos un array para guardar las celdas \r\n    // adjacentes que pertenecen al jugador\r\n    const validClick = []\r\n\r\n    // Iteramos por el array de grid de nuestra clase Game para\r\n    // cotejar si las celdas que estan en nearCells tienen registrado al\r\n    // jugador, de modo que sabemos que son casillas en las que ha hecho click\r\n    // anteriormente\r\n    for(let i= 0; i < nearCells.length; i++){\r\n      // buscamos dentro de nuestro registro de grid la id de celda\r\n      const targetCell = this.grid.find(cell => cell.id === nearCells[i]);\r\n      // Si la celda existe en el gri y además está registrado a nombre del jugador\r\n      // añadimos una celda válida dentro de las posibles celdas adyacentes\r\n      if(targetCell && targetCell.playerId === id){\r\n        validClick.push({validCell: true})\r\n      }\r\n    }\r\n\r\n    // Retornamos un valor booleanos que nos dice si almenos una\r\n    // de las casillas adjacentes a la casilla en la que se ha hecho click\r\n    // pertenece al jugador\r\n    return validClick.some(el => el.validCell)\r\n  }\r\n\r\n  checkCellClick ( e )\r\n  {\r\n    // chequeamos a que jugador le toca\r\n    const currentPlayerTurn = this.round.player;\r\n\r\n    // sacamos la id de la celda dentro del DOM\r\n    // sacamos los data asciados al número de row y la celda\r\n    const cellId = e.target.id;\r\n    const cellObj = {\r\n      row: e.target.dataset.row,\r\n      cell: e.target.dataset.cell\r\n    }\r\n    const cell = document.getElementById(cellId);\r\n\r\n    // comprobamos si es adjacente a la última seleccionada por el jugador\r\n    // siempre y cuando no sea el primer turno\r\n    if(this.round.roundNumber !== 1){\r\n      let isCellFilled, isAValidCellClick;\r\n      // comprobamos si está llena\r\n      isCellFilled = cell.classList.contains('isFilled')\r\n      // comprobamos si el click está en una casilla adjacente que pertenece al jugador\r\n      isAValidCellClick = this.checkValidCellClick(cellObj, currentPlayerTurn.id);\r\n\r\n      if(isCellFilled || !isAValidCellClick) {\r\n        return\r\n      };\r\n    }\r\n\r\n    // Añadimos la class isFilled que no permite pulsar la casilla\r\n    cell.classList.add('isFilled');\r\n    // Cambiamos la celda al color del jugador\r\n    cell.style.backgroundColor= currentPlayerTurn.color;\r\n    // Le sumamos 1 a sus casillas conquistadas\r\n    // y registramos la id de la celda como última posición\r\n    this.AddConqueredCell(currentPlayerTurn.id, cellId);\r\n\r\n    // Comprobamos que ninguno de los otros jugadores \r\n    // ha perdido.\r\n    this.checkOtherPlayerLoss(currentPlayerTurn.id);\r\n\r\n    // Comprobamos si ha ganado\r\n    if(this.totalCellsToWin === currentPlayerTurn.cellsConquered || this.players.length == 1){\r\n      console.log(`El jugador ${currentPlayerTurn.name} ha ganado!!!`);\r\n    }\r\n\r\n    // cambiamos el turno\r\n    this.checkTurn()\r\n  }\r\n\r\n  checkOtherPlayerLoss(currentPlayerId){\r\n      console.log(currentPlayerId);\r\n      let otherPlayers = this.players.filter((o)=> o.id !== currentPlayerId);\r\n      let defeated = [];\r\n      otherPlayers.forEach((player) => {\r\n        let aux = true;\r\n        console.log(player);\r\n          let conqueredCells = this.grid.filter((c)=> c.playerId == player.id);\r\n\r\n          if(conqueredCells.length > 0){\r\n            conqueredCells.forEach((cellObj)=>{\r\n              console.log(cellObj);\r\n              if(this.checkValidCellClick(cellObj, null)){\r\n                aux = false;\r\n              }\r\n            })\r\n          }else{\r\n            aux= false;\r\n          }\r\n        if(aux){ defeated.push(player); };\r\n      });\r\n\r\n      if(defeated.length > 0){\r\n        defeated.forEach((player)=>{\r\n          console.log(player);\r\n          this.defeatedPlayers.push(player);\r\n          this.players = this.players.filter(oplayer => oplayer.id !== player.id);\r\n        });\r\n\r\n        return true;\r\n      }\r\n      return false;\r\n  }\r\n\r\n  AddConqueredCell(playerId, cellId){\r\n    this.players = this.players.map(player => {\r\n      if(player.id === playerId){\r\n        player.cellsConquered += 1;\r\n      }\r\n      return player;\r\n    })\r\n    this.grid.forEach(cell => {\r\n      if(cell.id === cellId){\r\n        cell.playerId = this.round.player.id\r\n      }\r\n    })\r\n  }\r\n\r\n  createDomGrid ()\r\n  {\r\n    const size = this.gridSize;\r\n    const wrapper = document.getElementById( this.wrapper );\r\n    let rowCounter = 1;\r\n    let cellCounter = 1;\r\n    let cells = []\r\n\r\n    for ( let i = 1; i <= size * size; i++ ) {\r\n      let cellId = `cell${ rowCounter }-${ cellCounter }`;\r\n      let cell = document.createElement( 'div' );\r\n      cell.id = cellId;\r\n      cell.row = rowCounter;\r\n      cell.cell = cellCounter;\r\n      cell.className = `m-game-grid__cell cell-${rowCounter}-${cellCounter}`;\r\n      cell.dataset.cell = cellCounter;\r\n      cell.dataset.row = rowCounter;\r\n      cell.addEventListener( 'click', this.checkCellClick.bind( this ), false );\r\n      cells.push(cell);\r\n      cellCounter++;\r\n\r\n      // Si hay 20 celdas\r\n      if ( i % size === 0) {\r\n        // Creamos contenedor de la fila\r\n        let row = document.createElement( 'div' );\r\n        row.className = 'm-game-grid__row';\r\n\r\n        // Añadimos las 20 celdas a la fila\r\n        cells.forEach((cell, index) => {\r\n          row.appendChild(cell);\r\n        });\r\n\r\n        // Añadimos la fila al grid del HTML\r\n        wrapper.appendChild( row )\r\n\r\n        // Reiniciamos el array de celdas, \r\n        // el contador de celdas a 1 \r\n        // y añadimos 1 al contador de filas\r\n        cells = [];\r\n        cellCounter = 1;\r\n        rowCounter++;\r\n      }\r\n\r\n      // registamos la id de la casilla en nuestro registro de grid\r\n      this.grid[i-1] = {\r\n        id: cell.id,\r\n        row: cell.row,\r\n        cell: cell.cell,\r\n        playerId: null\r\n      }\r\n    }\r\n  }\r\n\r\n  generateGrid(gridSize){\r\n    return [...Array(gridSize * gridSize)]\r\n  }\r\n\r\n  buildToGamePlayers ( players )\r\n  {\r\n    return players.map( ( player, index ) => ( {\r\n      id: player.id,\r\n      name: player.getName(),\r\n      cellsConquered: 0,\r\n      color: this.colors[ index ]\r\n    } ) )\r\n  }\r\n\r\n  calculateTotalCellsToWin ( totalCells, players )\r\n  {\r\n    const numPlayers = players.length;\r\n    const otherConqueredCells = this.defeatedPlayers.reduce((acc, player) => acc.cellsConquered + player.cellsConquered, 0); // X casillas conquistadas por otros jugadores\r\n\r\n    this.totalCellsToWin =  Math.floor( (totalCells-otherConqueredCells) / numPlayers ) + 1\r\n  }\r\n\r\n  init(){\r\n    this.createDomGrid();\r\n    this.calculateTotalCellsToWin(this.totalCells, this.players)\r\n\r\n    // Generamos listener para manejar cambios en el localStorage\r\n  }\r\n}\r\n\r\nexport default Game;","class Player {\r\n  constructor(\r\n    id,\r\n    name,\r\n    avatar\r\n  ){\r\n    this.id = id;\r\n    this.name = name;\r\n    this.avatar = avatar;\r\n  }\r\n\r\n  getName(){\r\n    return this.name;\r\n  }\r\n\r\n  getAvatar(){\r\n    return this.avatar;\r\n  }\r\n}\r\n\r\nexport default Player;","class Room {\r\n  capacity = 4;\r\n  isOpen = true;\r\n  players = [];\r\n  roomBox = \"\";\r\n  game = \"\";\r\n\r\n  constructor(id, name, capacity){\r\n    this.id = id;\r\n    this.name = name;\r\n    this.capacity = capacity;\r\n  }\r\n\r\n  onDraggPlayer(user){\r\n\r\n    if(this.players.length === this.capacity){\r\n      this.isOpen = false;\r\n      disableRoom(this.id)\r\n      console.log('sala llena!')\r\n      return;\r\n    }\r\n\r\n    if(this.players.length > this.capacity || !this.isOpen){\r\n      console.log('La sala no acepta más jugadores')\r\n      return;\r\n    }\r\n\r\n    this.addToRoom(user);\r\n  }\r\n\r\n  addToRoom(user){\r\n    // Creamos jugador que recoge los datos del usuario arrastrado\r\n    const draggedPlayer = new Player(user.id, user.name, user.avatar);\r\n    this.players.push(draggedPlayer)\r\n    // Mostrar mensaje que se ha añadido un nuevo jugador\r\n\r\n    if(this.players > 1){\r\n      // Mostrar posibilidad de empezar a jugar\r\n    }\r\n  }\r\n\r\n  disableRoom(id){\r\n    const roomDivElement = document.getElementById(id);\r\n    roomDivElement.classList.add('isFull');\r\n  }\r\n\r\n  getPlayers(){\r\n    return players;\r\n  }\r\n\r\n  initGame(){\r\n    // Quitamos botón de play\r\n\r\n    // Inicializamos juego\r\n    const gridSize = 20;\r\n    this.game = Game('grid', this.players, gridSize);\r\n    this.game.init();\r\n  }\r\n\r\n\r\n}\r\n\r\nexport default Room;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// extracted by mini-css-extract-plugin\nexport {};","import Game from './Game';\r\nimport Player from './Player';\r\nimport Room from './Room';\r\nimport Dashboard from './DashBoard';\r\n\r\nexport {\r\n  Game, \r\n  Player,\r\n  Room,\r\n  Dashboard\r\n}"],"names":[],"sourceRoot":""}
