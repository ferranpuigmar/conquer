{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;AAAA,+DAAe,cAAc,EAAE,UAAU,EAAE,eAAe,EAAE,gBAAgB,EAAE,UAAU,GAAG,yCAAyC;;;;;;;;;;;;;;ACApI;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AClBqC;AACrC;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,SAAS;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA,0gBAA0gB;AAC1gB;AACA;AACA;AACA;;AAEA,OAAO,wDAAQ;AACf;AACA;;AAEA;AACA;;AAEA,+DAAe,SAAS;;;;;;;;;;;;;AC7BG;AACY;;AAEvC;AACA;AACA,+CAA+C,+CAAG,KAAK;;AAEvD;AACA,mCAAmC;;AAEnC;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA;AACA;;AAEA,SAAS,yDAAS;AAClB;;AAEA,+DAAe,EAAE;;;;;;;;;;;;ACvBc;;AAE/B;AACA,qCAAqC,sDAAU;AAC/C;;AAEA,+DAAe,QAAQ;;;;;;;;;;;;;ACNG;AACS;;AAEnC;AACA;AACA,qBAAqB,8CAAY;AACjC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,+BAA+B,UAAU;AACzC;AACA,kCAAkC,6CAAI;AACtC;AACA;AACA;;AAEA;;;AAGA;AACA,kCAAkC,UAAU;AAC5C;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+DAAe,SAAS,EAAC;;;;;;;;;;;;;;AChKgC;AACF;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAY;AAC5B,wDAAwD;AACxD;AACA,sDAAsD;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,mEAA2B;AACtC,qCAAqC,uBAAuB;AAC5D;AACA,WAAW,8DAAsB;AACjC,iCAAiC,iBAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,aAAa;AACtE,gDAAgD,QAAQ;AACxD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,mEAA2B;AACtD,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ,GAAG,KAAK;AAC7B,aAAa,IAAI,GAAG,SAAS;AAC7B,aAAa,QAAQ,GAAG,KAAK;AAC7B,aAAa,IAAI,GAAG,SAAS;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA,0BAA0B,iBAAiB;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,wBAAwB;AACxD;;AAEA;AACA,gCAAgC,sBAAsB;AACtD;;AAEA;AACA;;AAEA,6BAA6B,sDAAc;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sDAAc;AAC/C;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,kBAAkB;AACtC,0BAA0B,WAAW,GAAG,YAAY;AACpD;AACA;AACA;AACA;AACA,iDAAiD,WAAW,GAAG,YAAY;AAC3E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD,aAAa,iBAAiB,YAAY;AAC1F;AACA;AACA,+DAA+D,WAAW;AAC1E;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,iBAAiB,oEAA4B;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,mEAA2B;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,iBAAiB,+DAAuB;AACxC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,+DAAuB;AACtC;AACA;AACA,eAAe,oEAA4B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,8DAAsB;AACjD;AACA;AACA;AACA;AACA;;AAEA,+DAAe,IAAI,EAAC;;;;;;;;;;;;;ACjhBe;AACC;;AAEpC;AACA;AACA;AACA,gBAAgB,8CAAY;;AAE5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,EAAE;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+DAAe,KAAK,EAAC;;;;;;;;;;;;;;AC3Lc;AACC;;AAEpC;AACA;AACA;AACA,cAAc,8CAAY;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,EAAE;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,UAAU,gDAAM;AAChB;AACA;AACA;AACA,oBAAoB,wDAAwD;AAC5E;AACA,mBAAmB,wDAAwD;AAC3E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+DAAe,QAAQ,EAAC;;;;;;;;;;;;;;;AC9RiC;AACtB;AACT;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAY;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C,IAAI;AAClD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB,oEAA4B;AAC7C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0DAA0D,UAAU;AACpE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,uEAA+B;AAC1C,gCAAgC,WAAW;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,oEAA4B;AAC3C;AACA;AACA,eAAe,6DAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,iBAAiB,6DAAqB;AACtC;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6CAAI;AACxB;AACA;AACA;;AAEA,+DAAe,IAAI,EAAC;;;;;;;;;;;;;;;;AC7Pb;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACZe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;UCjCA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA,8CAA8C;;;;;WCA9C;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNA;;;;;;;;;;;;;;;;;;;;;ACA0B;AACA;AACU;AACF;AACN;;AAEsB","sources":["webpack://Conquer/./node_modules/uuid/dist/esm-browser/regex.js","webpack://Conquer/./node_modules/uuid/dist/esm-browser/rng.js","webpack://Conquer/./node_modules/uuid/dist/esm-browser/stringify.js","webpack://Conquer/./node_modules/uuid/dist/esm-browser/v4.js","webpack://Conquer/./node_modules/uuid/dist/esm-browser/validate.js","webpack://Conquer/./src/js/DashBoard.js","webpack://Conquer/./src/js/Game.js","webpack://Conquer/./src/js/Login.js","webpack://Conquer/./src/js/Register.js","webpack://Conquer/./src/js/Room.js","webpack://Conquer/./src/js/constants.js","webpack://Conquer/./src/js/utils.js","webpack://Conquer/webpack/bootstrap","webpack://Conquer/webpack/runtime/define property getters","webpack://Conquer/webpack/runtime/hasOwnProperty shorthand","webpack://Conquer/webpack/runtime/make namespace object","webpack://Conquer/./src/sass/style.scss?3ac4","webpack://Conquer/./src/js/index.js"],"sourcesContent":["export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import Room from \"./Room\";\nimport LocalStorage from \"./utils\";\n\nclass Dashboard {\n  roomsList = [];\n  localStorage = new LocalStorage();\n  avatarMobile;\n\n  constructor(initData) {\n    this.boxRooms = initData.boxRooms;\n  }\n\n  init() {\n    this.redirectToLogin();\n    this.generateRooms();\n    this.generatePlayerBox();\n    this.generateLogout();\n    this.avatarMobile = document.querySelector(\"#avatarMobile\");\n    //this.avatarMobile = new D\n    avatarMobile.addEventListener(\n      \"dragstart\", this.dragIniciado.bind(this),     \n      false\n    );\n    avatarMobile.addEventListener(\n      \"dragend\", this.dragFinalizado.bind(this),\n      false\n    );\n  }\n\n  dragIniciado(e) {\n    e.dataTransfer.setData(\"userAvatar\",\"avatarMobile\");\n  }\n  \n  dragFinalizado() {\n     \n  }\n\n\n  generateRooms() {\n    this.boxRooms.forEach((box, index) => {\n      const roomName = `Room ${index + 1}`;\n      // Generamos las instancias de las salas\n      this.roomsList[index] = new Room(box.id, roomName, 4);\n      // Iniciamos listeners para eventos del tipo storage\n      this.roomsList[index].initStorageEvents();\n      this.roomsList[index].initDragListeners();\n\n      const boxDiv = document.getElementById(box.id);\n\n\n      // Añadir clase para pintar caja\n      boxDiv.classList.add(`room${index + 1}`);\n      // Añadir títulos\n      const boxDivHeader = document.querySelector(\n        `#${box.id} .m-room-drop-item__header h3`\n      );\n      boxDivHeader.innerHTML = roomName;\n    });\n\n    this.generateStorageRooms();\n  }\n\n  generateStorageRooms() {\n    // Comprobamos si ya hay rooms en el LocalStorage\n    const existRooms = this.localStorage.getLocalStorage(\"roomsList\");\n    if (!existRooms) {\n      // Generamos localStorage inicial para las rooms\n      const roomsDataToStorage = this.roomsList.map((room) => ({\n        id: room.id,\n        usersRoom: [],\n        isOpen: true,\n        game: {\n          grid: [],\n          players: [],\n          defeatedPlaters: [],\n          totalCellsToWin: 0,\n          round: {\n            turn: 0,\n            roundNumber: 0,\n            player: null,\n          },\n        },\n      }));\n      const roomsDataType = {\n        eventType: null,\n        roomEventId: null,\n        rooms: roomsDataToStorage,\n      };\n      this.localStorage.setLocalStorage(\"roomsList\", roomsDataType);\n    }\n\n  }\n\n  generatePlayerBox() {\n    const data = this.localStorage.getLocalStorage(\"me\", \"session\");\n\n    if (data) {\n      const player = data;\n      const boxDiv = document.getElementById(\"my-user-box\");\n      const avatarDiv = boxDiv.querySelector(\".a-avatar\");\n      const nameDiv = boxDiv.querySelector(\".m-user-item__name\");\n      const roomDiv = boxDiv.querySelector(\".m-user-item__room\");\n      const roomName = this.getRoomName(player.favouriteRoom);\n\n      nameDiv.innerText = player.name;\n      roomDiv.innerText = roomName;\n      avatarDiv.dataset.id = player.id;\n      avatarDiv.dataset.avatar = player.avatar;\n      avatarDiv.dataset.color = player.color;\n      avatarDiv.classList.add(player.avatar);\n\n      if (this.isPlayerInRooms(player)) {\n        avatarDiv.classList.add(\"hidden\");\n      } else {\n        avatarDiv.classList.remove(\"hidden\");\n      }\n    } else {\n      // Aquí va la redicción si el usuario no esta conectado;\n      console.log(\"usuario no conectado\");\n    }\n  }\n\n  generateLogout() {\n    const logoutBtn = document.getElementById(\"logout\");\n    const player = this.localStorage.getLocalStorage(\"me\", \"session\");\n\n    logoutBtn.addEventListener(\"click\", function () {\n      this.rooms.takeOutFromRoom(player);\n      this.localStorage.setLocalStorage(\"me\", null, \"session\");\n      this.redirectToLogin();\n    });\n  }\n\n  isPlayerInRooms(player) {\n    let allPlayers = [];\n    this.roomsList.forEach((room) => {\n      allPlayers.concat(room.players);\n    });\n    return !!allPlayers.find((pl) => pl.id === player.id);\n  }\n\n  getRoomName(id) {\n    let index = -1;\n    this.boxRooms.find(function (item, i) {\n      if (item.id === id) {\n        index = i;\n        return i;\n      }\n    });\n    return \"ROOM \" + (index + 1);\n  }\n\n  redirectToLogin() {\n    let user = this.localStorage.getLocalStorage(\"me\", \"session\");\n    if (!user) {\n      window.location.href = \"/\";\n    }\n  }\n}\n\nexport default Dashboard;\n","import { EVENT_TYPES, MESSAGE_TYPES } from \"./constants\";\nimport LocalStorage, { getNewGameInfo } from \"./utils\";\n\nclass Game {\n  colors = [\"Purple\", \"Aquamarine\", \"CadetBlue\", \"DeepPink\"];\n  grid = [];\n  defeatedPlayers = [];\n  wrapper = document.getElementById(\"grid\");\n  totalCellsToWin = 0;\n  storage = new LocalStorage();\n  waittingDiv = document.querySelector(\"#roomMessage\"); // Div del mensaje de espera\n  roomsList;\n  roundTitle = document.getElementById(\"roundTitle\"); // Número del Round\n  pannelInfo = document.getElementById(\"roomPannelInfo\");\n\n  constructor(roomId, playerInfo, players, gameSize) {\n    this.player = playerInfo;\n    this.players = this.userToPlayerDTO(players);\n    this.gridSize = gameSize;\n    this.totalCells = gameSize * gameSize;\n    this.round = { turn: 1, roundNumber: 1, player: this.players[0] };\n    this.grid = this.generateGrid(gameSize);\n    this.roomId = roomId;\n  }\n\n  isMyTurn(round) {\n    return round.player.id === this.player.id;\n  }\n\n  getPlayers() {\n    return this.players;\n  }\n\n  // Método que calcula la nueva info del Round después de un movimiento\n  calculateNewRoundInfo() {\n    const newTurn = this.round.turn + 1;\n    const isTurnEnd = newTurn > this.players.length;\n    const newRoundTitle = isTurnEnd\n      ? this.round.roundNumber + 1\n      : this.round.roundNumber;\n\n    // Si el último jugador ha movido cambiamos el número del Round\n    // si no, aumentamos en 1 el turno\n    if (isTurnEnd) {\n      this.roundTitle.querySelector(\"span\").innerHTML = newRoundTitle;\n    }\n\n    return {\n      roundNumber: newRoundTitle,\n      turn: isTurnEnd ? 1 : newTurn,\n      player: isTurnEnd ? this.players[0] : this.players[newTurn - 1],\n    };\n  }\n\n  showRoomMessage(type) {\n    let message;\n    const messageDiv = document.querySelector(\"#roomMessage\");\n    switch (type) {\n      case MESSAGE_TYPES.WAITTING_TURN:\n        message = `Es el turno de  ${this.round.player.name}, espera a que haga su movimiento`;\n        break;\n      case MESSAGE_TYPES.HAS_LOST:\n        message = `Lo sentimos ${this.player.name}, te han dejado sin casillas. ¡Has perdido!`;\n        break;\n      default:\n        return \"\";\n    }\n    this.waittingDiv.classList.remove(\"d-none\");\n    const messageType = this.player.hasLost ? \"danger\" : \"info\";\n    const messageContentDiv = `<div class=\"alert alert-${messageType} fade show\" role=\"alert\">\n                <span id=\"roomMessageContent\">${message}</span>\n              </div>`;\n    messageDiv.innerHTML = messageContentDiv;\n  }\n\n  hideRoomMessage() {\n    this.waittingDiv.classList.add(\"d-none\");\n    this.waittingDiv.innerHTML = \"\";\n  }\n\n  // Método que chequea que sea el turno del jugador\n  // y actualiza la información del juego que viene por el localStorage\n  checkTurn(currentRoom) {\n    if (this.round.player.id !== this.player.id) {\n      this.showRoomMessage(MESSAGE_TYPES.WAITTING_TURN);\n    } else {\n      this.hideRoomMessage();\n    }\n\n    // Actualizamos juego para el jugador\n    const updateGame = currentRoom.game;\n    this.roundTitle.querySelector(\"span\").innerHTML =\n      updateGame.round.roundNumber;\n\n    // Iteramos sobre las celdas del grid del DOM\n    // las cotejamos con nuestro grid actualizado del localStorage\n    // Si existe un id dentro del grid que es = a el del id de la cell\n    // cambiamos el color de la celda\n    const cells = this.wrapper.querySelectorAll(\".m-game-grid__cell\");\n    cells.forEach((cell, index) => {\n      const cellId = cell.id;\n      if (this.grid[index].id && this.grid[index].id === cellId) {\n        cell.style.backgroundColor = this.grid[index].color;\n      }\n    });\n  }\n\n  // Método que calcula que casillas son clicables por el jugador\n  // de momento es en cruz\n  checkValidCellClick(cellObj, id) {\n    // row de la casilla clickada\n    const row = Number(cellObj.row);\n    // celda de la casilla clickada\n    const cell = Number(cellObj.cell);\n\n    // Generamos posibles celdas adjacentes que pueden ser del jugador\n    const nearCells = [\n      `cell${row + 1}-${cell}`,\n      `cell${row}-${cell + 1}`,\n      `cell${row - 1}-${cell}`,\n      `cell${row}-${cell - 1}`,\n    ];\n    // Inicializamos un array para guardar las celdas\n    // adjacentes que pertenecen al jugador\n    const validClick = [];\n\n    // Iteramos por el array de grid de nuestra clase Game para\n    // cotejar si las celdas que estan en nearCells tienen registrado al\n    // jugador, de modo que sabemos que son casillas en las que ha hecho click\n    // anteriormente\n    for (let i = 0; i < nearCells.length; i++) {\n      // buscamos dentro de nuestro registro de grid la id de celda\n      const targetCell = this.grid.find((cell) => cell.id === nearCells[i]);\n      // Si la celda existe en el gri y además está registrado a nombre del jugador\n      // añadimos una celda válida dentro de las posibles celdas adyacentes\n      if (targetCell && targetCell.playerId === id) {\n        validClick.push({ validCell: true });\n      }\n    }\n\n    // Retornamos un valor booleanos que nos dice si almenos una\n    // de las casillas adjacentes a la casilla en la que se ha hecho click\n    // pertenece al jugador\n    return validClick.some((el) => el.validCell);\n  }\n\n  // Método que chequea la celda que se ha clicado en el tablero\n  // Chequeamos que sea clicable\n  // Chequeamos si el jugador ha ganado\n  // Actualizamos el localStorage con ese clic\n  checkCellClick(e) {\n    if (!this.isMyTurn(this.round)) return;\n\n    // chequeamos a que jugador le toca\n    const currentPlayerTurn = this.round.player;\n\n    // sacamos la id de la celda dentro del DOM\n    // sacamos los data asciados al número de row y la celda\n    const cellId = e.target.id;\n    const cellObj = {\n      row: e.target.dataset.row,\n      cell: e.target.dataset.cell,\n    };\n    const cell = document.getElementById(cellId);\n\n    // comprobamos si es adjacente a la última seleccionada por el jugador\n    // siempre y cuando no sea el primer turno\n    if (this.round.roundNumber !== 1) {\n      let isCellFilled, isAValidCellClick;\n      // comprobamos si está llena\n      isCellFilled = cell.classList.contains(\"isFilled\");\n      // comprobamos si el click está en una casilla adjacente que pertenece al jugador\n      isAValidCellClick = this.checkValidCellClick(\n        cellObj,\n        currentPlayerTurn.id\n      );\n\n      if (isCellFilled || !isAValidCellClick) {\n        return;\n      }\n    }\n\n    // Añadimos la class isFilled que no permite pulsar la casilla\n    cell.classList.add(\"isFilled\");\n    // Cambiamos la celda al color del jugador\n    cell.style.backgroundColor = currentPlayerTurn.color;\n    // Le sumamos 1 a sus casillas conquistadas\n    // y registramos la id de la celda como última posición\n    this.AddConqueredCell(currentPlayerTurn.id, cellId);\n\n    // Comprobamos que ninguno de los otros jugadores\n    // ha perdido.\n    this.checkOtherPlayerLoss(currentPlayerTurn.id);\n\n    // Comprobamos si ha ganado\n    if (this.totalCellsToWin === currentPlayerTurn.cellsConquered) {\n      console.log(`El jugador ${currentPlayerTurn.name} ha ganado!!!`);\n    }\n\n    if (this.players.length == 1) {\n      console.log(`El jugador ${this.players[0].name} ha ganado!!!`);\n    }\n\n    // Actualizamos información del round\n    this.round = this.calculateNewRoundInfo();\n\n    const newGameToStorage = getNewGameInfo(this);\n\n    // Enviamos update al storage\n    this.updateGame(this.getRoomsList(), newGameToStorage);\n    const currentRoom = this.getRoomsList().rooms.find(\n      (room) => room.id === this.roomId\n    );\n    this.checkTurn(currentRoom);\n  }\n\n  // Devuelve la key roomsList del localStorage\n  getRoomsList() {\n    return this.storage.getLocalStorage(\"roomsList\");\n  }\n\n  checkOtherPlayerLoss(currentPlayerId) {\n    let otherPlayers = this.players.filter(\n      (otherPlayer) => otherPlayer.id !== currentPlayerId\n    );\n    let defeated = [];\n    otherPlayers.forEach((player) => {\n      let playerHasLost = true;\n      let conqueredCells = this.grid.filter(\n        (cell) => cell.playerId === player.id\n      );\n\n      if (conqueredCells.length > 0) {\n        conqueredCells.forEach((cellObj) => {\n          if (this.checkValidCellClick(cellObj, null)) {\n            playerHasLost = false;\n          }\n        });\n      } else {\n        playerHasLost = false;\n      }\n      if (playerHasLost) {\n        defeated.push(player);\n      }\n    });\n\n    // Si hay jugadores que han sido eliminados\n    // los añadimos al state de defeatedPlayers\n    // enviamos evento para que se enteren que han perdido\n    if (defeated.length > 0) {\n      defeated.forEach((player) => {\n        this.defeatedPlayers.push(player);\n        this.players = this.players.filter(\n          (oplayer) => oplayer.id !== player.id\n        );\n        // Enviamos evento que el user ha perdido\n        const newGameToStorage = getNewGameInfo(this);\n        this.notifySomeoneHasLost(newGameToStorage);\n      });\n\n      this.calculateTotalCellsToWin(this.totalCells, this.players);\n      return true;\n    }\n\n    return false;\n  }\n\n  // Método que añade una casilla al total\n  // de casillas conquistadas del jugador\n  AddConqueredCell(playerId, cellId) {\n    this.players = this.players.map((player) => {\n      if (player.id === playerId) {\n        player.cellsConquered += 1;\n      }\n      return player;\n    });\n    this.grid.forEach((cell) => {\n      if (cell.id === cellId) {\n        cell.playerId = this.round.player.id;\n        cell.color = this.round.player.color;\n      }\n    });\n  }\n\n  defeatPlayer(player) {\n    this.defeatedPlayers.push(player);\n    this.players = this.players.filter((oplayer) => oplayer.id !== player.id);\n    console.log(`El jugador ${player.name} ha perdido!!!`);\n  }\n\n  takeOutFromGame(player) {\n    let is_in = this.players.find(\n      (current_player) => current_player.id === player.id\n    );\n    if (!!is_in) {\n      this.defeatPlayer(player);\n      this.calculateTotalCellsToWin(this.totalCells, this.players);\n    }\n  }\n\n  createDomGrid() {\n    const size = this.gridSize;\n    this.wrapper.innerHTML = \"\";\n    let rowCounter = 1;\n    let cellCounter = 1;\n    let cells = [];\n\n    for (let i = 1; i <= size * size; i++) {\n      let cellId = `cell${rowCounter}-${cellCounter}`;\n      let cell = document.createElement(\"div\");\n      cell.id = cellId;\n      cell.row = rowCounter;\n      cell.cell = cellCounter;\n      cell.className = `m-game-grid__cell cell-${rowCounter}-${cellCounter}`;\n      cell.dataset.cell = cellCounter;\n      cell.dataset.row = rowCounter;\n      cell.addEventListener(\"click\", this.checkCellClick.bind(this), false);\n      cells.push(cell);\n      cellCounter++;\n\n      // Si hay 20 celdas\n      if (i % size === 0) {\n        // Creamos contenedor de la fila\n        let row = document.createElement(\"div\");\n        row.className = \"m-game-grid__row\";\n\n        // Añadimos las 20 celdas a la fila\n        cells.forEach((cell, index) => {\n          row.appendChild(cell);\n        });\n\n        // Añadimos la fila al grid del HTML\n        this.wrapper.appendChild(row);\n\n        // Reiniciamos el array de celdas,\n        // el contador de celdas a 1\n        // y añadimos 1 al contador de filas\n        cells = [];\n        cellCounter = 1;\n        rowCounter++;\n      }\n\n      // registamos la id de la casilla en nuestro registro de grid\n      this.grid[i - 1] = {\n        id: cell.id,\n        row: cell.row,\n        cell: cell.cell,\n        playerId: null,\n        color: null,\n      };\n    }\n  }\n\n  createLegend(players) {\n    const existingPlayers = players ?? this.players;\n    const userLegend = existingPlayers\n      .map(\n        (player) =>\n          `<li><span style=\"background-color: ${player.color}\"></span><span>${player.name}</span></li>`\n      )\n      .join(\"\");\n    this.pannelInfo.innerHTML = `<span>Jugadores:</span> <ul>${userLegend}</ul>`;\n  }\n\n  // Método que inicializa el registro de grid según las dimensiones\n  generateGrid(gridSize) {\n    return [...Array(gridSize * gridSize)];\n  }\n\n  // Método que transforma los datos que nos llegan de los usuarios\n  // a datos de jugador que necesitamos para gestionar el juego\n  userToPlayerDTO(players) {\n    return players.map((player, index) => ({\n      id: player.id,\n      name: player.name,\n      cellsConquered: 0,\n      color: this.colors[index],\n      hasLost: false,\n    }));\n  }\n\n  // Método que calcula el total de celdas que tiene\n  // que rellenar un jugador para ganar\n  calculateTotalCellsToWin(totalCells, players) {\n    const numPlayers = players.length;\n    let totalDefeatedCells = 0;\n\n    this.defeatedPlayers.forEach((defeatyedPlayer) => {\n      const cellsConquered = defeatyedPlayer.cellsConquered;\n      totalDefeatedCells += cellsConquered;\n    });\n\n    this.totalCellsToWin =\n      Math.floor((totalCells - totalDefeatedCells) / numPlayers) + 1;\n  }\n\n  //Evento para notificar que alguien ha perdido\n  notifySomeoneHasLost(newGameInfo) {\n    const updateRooms = this.getRoomsList().rooms.map((room) => {\n      if (room.id === this.roomId) {\n        room.game = newGameInfo;\n      }\n      return room;\n    });\n\n    const roomListUpdate = {\n      eventType: EVENT_TYPES.SOMEONE_HAS_LOST,\n      roomEventId: this.roomId,\n      rooms: updateRooms,\n    };\n\n    this.storage.setLocalStorage(\"roomsList\", roomListUpdate);\n  }\n\n  // Método que inicializa el juego\n  init(isCallWithEvent) {\n    this.createDomGrid();\n    this.calculateTotalCellsToWin(this.totalCells, this.players);\n    this.initStorageEvents();\n    this.roundTitle.querySelector(\"span\").innerHTML = 1;\n    this.roundTitle.classList.remove(\"d-none\");\n    this.createLegend();\n\n    if (!this.isMyTurn(this.round)) {\n      this.showRoomMessage(MESSAGE_TYPES.WAITTING_TURN);\n    }\n\n    // Inicializamos los datos del juego partiendo del orden establecido\n    // por orden de conexión a la sala, que viene dado por el userRomms del localStorage\n    // mediante isCallWithEvent, si el juego se ha inciado por evento no lo hacemos ya que\n    // inicialmente ya lo ha iniciado el primero que le ha dado al botón de play\n    if (!isCallWithEvent) {\n      const initNewGameToStorage = {\n        defeatedPlayers: this.defeatedPlayers,\n        grid: this.grid,\n        players: this.players,\n        round: this.round,\n        totalCellsToWin: this.totalCellsToWin,\n      };\n\n      this.updateGame(this.getRoomsList(), initNewGameToStorage);\n    }\n  }\n\n  // Método que actualiza el localStorage del juego\n  // y añade un evento del tipo update para que el listener del storage\n  // reaccione en el resto de tabs de jugador\n  updateGame(roomsList, newGameInfo) {\n    const updateRooms = roomsList.rooms.map((room) => {\n      if (room.id === this.roomId) {\n        room.game = newGameInfo;\n      }\n      return room;\n    });\n\n    const roomListUpdate = {\n      eventType: EVENT_TYPES.UPDATE_GAME,\n      roomEventId: this.roomId,\n      rooms: updateRooms,\n    };\n\n    this.storage.setLocalStorage(\"roomsList\", roomListUpdate);\n  }\n\n  // Método que añade el evento storage al juego\n  initStorageEvents() {\n    window.addEventListener(\"storage\", (e) => {\n      // por cada sala se lanza este evento\n      if (e.key === \"roomsList\") {\n        const roomsList = JSON.parse(e.newValue);\n\n        switch (roomsList.eventType) {\n          case EVENT_TYPES.UPDATE_GAME:\n            !this.player.hasLost && this.handleUpdateEventGame(roomsList);\n            break;\n          case EVENT_TYPES.SOMEONE_HAS_LOST:\n            !this.player.hasLost && this.handleSomeoneHasLostEvent(roomsList);\n            break;\n          default:\n            return;\n        }\n      }\n    });\n  }\n\n  // Recibe el evento update y cambia la info de los demás jugadores\n  // que estan conectados a la partida y aún no es su turno\n  handleUpdateEventGame(roomsList) {\n    console.log(\"update game from event\");\n    // Si la sala no es la que tiene el evento no hacemos nada\n    if (roomsList.roomEventId !== this.roomId) return;\n\n    const currentRoom = roomsList.rooms.find(\n      (room) => room.id === roomsList.roomEventId\n    );\n\n    // Actualizamos grid de la clase\n    this.grid = currentRoom.game.grid;\n    this.round = currentRoom.game.round;\n    this.totalCellsToWin = currentRoom.game.totalCellsToWin;\n    this.players = currentRoom.game.players;\n\n    // Chequeamos el turno del jugador\n    this.checkTurn(currentRoom);\n  }\n\n  // Recibe el evento que alguien ha perdido y lo notifica a aquella id\n  // de usuariso que corresponda\n  handleSomeoneHasLostEvent(roomsList) {\n    // Si la sala no es la que tiene el evento no hacemos nada\n    if (roomsList.roomEventId !== this.roomId) return;\n\n    const currentRoom = roomsList.rooms.find(\n      (room) => roomsList.roomEventId === room.id\n    );\n\n    // Sacamos las id que hay dentro de los array de jugadores que han perdido\n    const defeatedPlayersId = currentRoom.game.defeatedPlayers.map(\n      (defeatedPlayer) => defeatedPlayer.id\n    );\n\n    if (defeatedPlayersId.includes(this.player.id)) {\n      this.showRoomMessage(MESSAGE_TYPES.HAS_LOST);\n      this.player.hasLost = true;\n      this.createLegend(currentRoom.game.players);\n    }\n  }\n}\n\nexport default Game;\n","import LocalStorage from \"./utils\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nclass Login {\n  fields = {};\n  errors = {};\n  storage = new LocalStorage();\n\n  constructor(loginFields) {\n    this.form = document.getElementById(loginFields.formId);\n    this.emailInput = document.getElementById(loginFields.emailId);\n    this.passwordInput = document.getElementById(loginFields.passwordId);\n    this.registerSubmitBtn = document.getElementById(loginFields.submtBtn);\n  }\n\n  validateEmail(name, element, value) {\n    let message, isValid;\n\n    if (value === \"\") {\n      message = \"El email no puede estar vacío\";\n      isValid = false;\n    }\n\n    if (value !== \"\") {\n      const regex =\n        /^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/;\n      isValid = regex.test(value);\n      message = isValid ? \"\" : \"El email no es válido\";\n    }\n\n    if (isValid) {\n      delete this.errors[name];\n      element.classList.remove(\"is-invalid\");\n      document.getElementById(`${element.id}_error`).innerHTML = \"\";\n      this.fields[name].value = value;\n      return;\n    } else {\n      this.fields[name].value = \"\";\n    }\n\n    this.errors[name] = {\n      element: element,\n      message,\n    };\n  }\n\n  validatePassword(name, element, value) {\n    const isValid = value !== \"\";\n    const message = isValid ? \"\" : \"El password no puede estar vacío\";\n\n    if (isValid) {\n      delete this.errors[name];\n      element.classList.remove(\"is-invalid\");\n      document.getElementById(`${element.id}_error`).innerHTML = \"\";\n      this.fields[name].value = value;\n      return;\n    } else {\n      this.fields[name].value = \"\";\n    }\n\n    this.errors[name] = {\n      element: element,\n      message,\n    };\n  }\n\n  registerLoginFields() {\n    const requiredFields = [\n      {\n        name: \"emailInput\",\n        element: this.emailInput,\n        validate: this.validateEmail.bind(this),\n      },\n      {\n        name: \"passwordInput\",\n        element: this.passwordInput,\n        validate: this.validatePassword.bind(this),\n      },\n    ];\n    requiredFields.forEach((field) => {\n      this.fields[field.name] = {\n        name: field.name,\n        validate: field.validate,\n        element: field.element,\n        value: \"\",\n      };\n    });\n  }\n\n  assignListeners() {\n    this.form.addEventListener(\"submit\", this.send.bind(this));\n  }\n\n  init() {\n    this.redirectToRooms();\n    this.registerLoginFields();\n    this.assignListeners();\n  }\n\n  loginUser(data) {\n    const allUSers = this.storage.getLocalStorage(\"users\");\n    const newUser = data;\n    const user = allUSers?.find((user) => user.email === newUser.email);\n    if (!user) {\n      this.showErrorMessage(\"No existe nadie con este email\");\n      return;\n    }\n    const passWordIsValid = allUSers.find(\n      (user) => user.password === newUser.password\n    );\n    if (!passWordIsValid) {\n      this.showErrorMessage(\"La contraseña no es válida\");\n      return;\n    }\n\n    // Aqui va la lógica para poner al \"user\" (línea 95) dentro de los usuarios conectados\n    this.storage.setLocalStorage(\"me\", user, \"session\");\n\n    //!Temporal\n    const connectedUsers = this.storage.getLocalStorage(\"connectedUsers\");\n    if (!connectedUsers) {\n      this.storage.setLocalStorage(\"connectedUsers\", [user]);\n    } else {\n      const existConnectedUser = connectedUsers.find(\n        (connectedUser) => connectedUser.id === user.id\n      );\n      if (!existConnectedUser) {\n        connectedUsers.push(user);\n        this.storage.setLocalStorage(\"connectedUsers\", connectedUsers);\n      }\n    }\n\n    // También se tiene que redirigir al usuario a la ruta /rooms\n    window.location.href = \"/rooms\";\n  }\n\n  showErrorMessage(message) {\n    const messageElement = document.getElementById(\"errorMessage\");\n    messageElement.innerHTML = message;\n    messageElement.classList.remove(\"d-none\");\n  }\n\n  redirectToRooms() {\n    let user = this.storage.getLocalStorage(\"me\", \"session\");\n    if (user) {\n      window.location.href = \"/rooms\";\n    }\n  }\n\n  send(e) {\n    e.preventDefault();\n    const fields = this.fields;\n\n    const errorMessageElement = document.getElementById(\"errorMessage\");\n    errorMessageElement.classList.add(\"d-none\");\n\n    Object.keys(fields).forEach((field) => {\n      this.fields[field].validate(\n        fields[field].name,\n        fields[field].element,\n        fields[field].element.value\n      );\n    });\n\n    const existErrors = Object.keys(this.errors).length !== 0;\n\n    if (existErrors) {\n      Object.keys(this.errors).forEach((error) => {\n        const inputElement = this.errors[error].element;\n        const msgErrorElement = `${inputElement.id}_error`;\n        inputElement.classList.add(\"is-invalid\");\n        document.getElementById(msgErrorElement).innerHTML =\n          this.errors[error].message;\n      });\n      return;\n    }\n\n    const data = {\n      email: this.fields.emailInput.value,\n      password: this.fields.passwordInput.value,\n    };\n\n    // Método para enviar la información al localStorage, al apartado de usuaros conectados\n    this.loginUser(data);\n  }\n}\n\nexport default Login;\n","import LocalStorage from \"./utils\";\nimport { v4 as uuidv4 } from \"uuid\";\n\nclass Register {\n  fields = {};\n  errors = {};\n  local = new LocalStorage();\n\n  constructor(registerFields) {\n    this.form = document.getElementById(registerFields.formId);\n    this.nameInput = document.getElementById(registerFields.nameId);\n    this.emailInput = document.getElementById(registerFields.emailId);\n    this.passwordInput = document.getElementById(registerFields.passwordId);\n    this.favouriteRoom = document.getElementById(\n      registerFields.favouriteRoomId\n    );\n    this.avatarWrapper = document.getElementById(\n      registerFields.avatarWrapperId\n    );\n    this.registerSubmitBtn = document.getElementById(registerFields.submtBtn);\n  }\n\n  onSelectAvatar(e) {\n    const avatarId = e.target.id;\n    const avatarDiv = document.getElementById(avatarId);\n    this.selectAvatar(avatarDiv);\n  }\n\n  selectAvatar(selected) {\n    const avatars = this.avatarWrapper.querySelectorAll(\".a-avatar\");\n    avatars.forEach((avatar) => {\n      avatar.classList.remove(\"active\");\n    });\n\n    selected.classList.add(\"active\");\n  }\n\n  assignListeners() {\n    const avatars = this.avatarWrapper.querySelectorAll(\".a-avatar\");\n    avatars.forEach((avatar) => {\n      avatar.addEventListener(\"click\", this.onSelectAvatar.bind(this));\n    });\n\n    this.form.addEventListener(\"submit\", this.send.bind(this));\n  }\n\n  resetForm() {\n    for (let field in this.fields) {\n      const fieldEl = this.fields[field];\n      fieldEl.value = \"\";\n      if (fieldEl.name === \"favouriteRoom\") {\n        fieldEl.element.value = \"0\";\n      } else {\n        fieldEl.element.value = \"\";\n      }\n    }\n\n    const defaultAvatar = document.getElementById(\"avatar1\");\n    this.selectAvatar(defaultAvatar);\n  }\n\n  validateName(name, element, value) {\n    const isValid = value !== \"\";\n    const message = isValid ? \"\" : \"El nombre no puede estar vacío\";\n\n    if (isValid) {\n      delete this.errors[name];\n      element.classList.remove(\"is-invalid\");\n      document.getElementById(`${element.id}_error`).innerHTML = \"\";\n      this.fields[name].value = value;\n      return;\n    } else {\n      this.fields[name].value = \"\";\n    }\n\n    this.errors[name] = {\n      element: element,\n      message,\n    };\n  }\n\n  validateEmail(name, element, value) {\n    let message, isValid;\n\n    if (value === \"\") {\n      message = \"El email no puede estar vacío\";\n      isValid = false;\n    }\n\n    if (value !== \"\") {\n      const regex =\n        /^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/;\n      isValid = regex.test(value);\n      message = isValid ? \"\" : \"El email no es válido\";\n    }\n\n    if (isValid) {\n      delete this.errors[name];\n      element.classList.remove(\"is-invalid\");\n      document.getElementById(`${element.id}_error`).innerHTML = \"\";\n      this.fields[name].value = value;\n      return;\n    } else {\n      this.fields[name].value = \"\";\n    }\n\n    this.errors[name] = {\n      element: element,\n      message,\n    };\n  }\n\n  validatePassword(name, element, value) {\n    const isValid = value !== \"\";\n    const message = isValid ? \"\" : \"El password no puede estar vacío\";\n\n    if (isValid) {\n      delete this.errors[name];\n      element.classList.remove(\"is-invalid\");\n      document.getElementById(`${element.id}_error`).innerHTML = \"\";\n      this.fields[name].value = value;\n      return;\n    } else {\n      this.fields[name].value = \"\";\n    }\n\n    this.errors[name] = {\n      element: element,\n      message,\n    };\n  }\n\n  validateFavouriteRoom(name, element, value) {\n    const isValid = value !== \"0\";\n    const message = isValid ? \"\" : \"Debes seleccionar una sala\";\n\n    if (isValid) {\n      delete this.errors[name];\n      element.classList.remove(\"is-invalid\");\n      document.getElementById(`${element.id}_error`).innerHTML = \"\";\n      this.fields[name].value = value;\n      return;\n    } else {\n      this.fields[name].value = \"\";\n    }\n\n    this.errors[name] = {\n      element: element,\n      message,\n    };\n  }\n\n  registerFields() {\n    const requiredFields = [\n      {\n        name: \"nameInput\",\n        element: this.nameInput,\n        validate: this.validateName.bind(this),\n      },\n      {\n        name: \"emailInput\",\n        element: this.emailInput,\n        validate: this.validateEmail.bind(this),\n      },\n      {\n        name: \"passwordInput\",\n        element: this.passwordInput,\n        validate: this.validatePassword.bind(this),\n      },\n      {\n        name: \"favouriteRoom\",\n        element: this.favouriteRoom,\n        validate: this.validateFavouriteRoom.bind(this),\n      },\n    ];\n    requiredFields.forEach((field) => {\n      this.fields[field.name] = {\n        name: field.name,\n        validate: field.validate,\n        element: field.element,\n        value: \"\",\n      };\n    });\n  }\n\n  init() {\n    this.redirectToRooms();\n    this.assignListeners();\n    this.registerFields();\n  }\n\n  saveUser(data) {\n    const allUSers = this.local.getLocalStorage(\"users\");\n    const newUser = data;\n\n    if (!allUSers || allUSers.length === 0) {\n      this.local.setLocalStorage(\"users\", [newUser]);\n      this.resetForm();\n      this.showSuccesMessage();\n      return;\n    }\n\n    const existUSer = allUSers.find((user) => user.email === newUser.email);\n    if (existUSer) {\n      this.showErrorMessage(\"Ya existe un usuario con este email\");\n      return;\n    }\n\n    allUSers.push(newUser);\n    this.local.setLocalStorage(\"users\", allUSers);\n    this.resetForm();\n    this.showSuccesMessage();\n  }\n\n  showErrorMessage(message) {\n    const messageElement = document.getElementById(\"errorMessage\");\n    messageElement.innerHTML = message;\n    messageElement.classList.remove(\"d-none\");\n  }\n\n  showSuccesMessage() {\n    const message = \"Tu usuario se ha registrado correctamente.\";\n    const messageElement = document.getElementById(\"successMessage\");\n    const loginButton = document.getElementById(\"successButton\");\n    const submitButton = document.getElementById(\"submitButton\");\n    messageElement.innerHTML = message;\n    messageElement.classList.remove(\"d-none\");\n    loginButton.classList.remove(\"d-none\");\n    submitButton.classList.add(\"d-none\");\n\n    setTimeout(() => {\n      messageElement.classList.add(\"d-none\");\n      submitButton.classList.remove(\"d-none\");\n    }, 2000);\n  }\n\n  send(e) {\n    e.preventDefault();\n    const fields = this.fields;\n\n    const errorMessageElement = document.getElementById(\"errorMessage\");\n    errorMessageElement.classList.add(\"d-none\");\n\n    Object.keys(fields).forEach((field) => {\n      this.fields[field].validate(\n        fields[field].name,\n        fields[field].element,\n        fields[field].element.value\n      );\n    });\n\n    const existErrors = Object.keys(this.errors).length !== 0;\n\n    if (existErrors) {\n      Object.keys(this.errors).forEach((error) => {\n        const inputElement = this.errors[error].element;\n        const msgErrorElement = `${inputElement.id}_error`;\n        inputElement.classList.add(\"is-invalid\");\n        document.getElementById(msgErrorElement).innerHTML =\n          this.errors[error].message;\n      });\n      return;\n    }\n\n    const data = {\n      id: uuidv4(),\n      name: this.fields.nameInput.value,\n      email: this.fields.emailInput.value,\n      password: this.fields.passwordInput.value,\n      avatar: `mod${this.avatarWrapper.querySelector(\".active\").dataset.mod}`,\n      favouriteRoom: this.fields.favouriteRoom.value,\n      color: `mod${this.avatarWrapper.querySelector(\".active\").dataset.mod}`,\n    };\n\n    // Evento para enviar la información al localStorage, al apartado de usuaros registrados\n    this.saveUser(data);\n  }\n\n  redirectToRooms(){\n    let user = this.local.getLocalStorage(\"me\", \"session\");\n    if(user){\n      window.location.href = \"/rooms\";\n    }\n  }\n}\n\nexport default Register;\n","import { EVENT_TYPES, MESSAGE_TYPES } from \"./constants\";\nimport LocalStorage from \"./utils\";\nimport Game from \"./Game\";\nclass Room {\n  capacity = 4;\n  isOpen = true;\n  players = [];\n  roomBox = \"\";\n  game = \"\";\n  storage = new LocalStorage();\n  playButtonDiv = document.getElementById(\"playButton\");\n  roomBox;\n  currentAvatar;\n\n  constructor(id, name, capacity) {\n    this.id = id;\n    this.name = name;\n    this.capacity = capacity;\n    this.roomBox = document.querySelector(`#${id} .m-room-drop-item__image`);\n  }\n\n  initDragListeners() {\n    this.roomBox.addEventListener(\"drop\", this.onDropPlayer.bind(this));\n    this.roomBox.addEventListener(\"dragover\", this.dragSobreContenedor.bind(this));\n    this.roomBox.addEventListener(\"dragleave\", this.dragSaleContenedor.bind(this));\n  }\n\n  dragSaleContenedor(e) {\n    e.preventDefault();\n  }\n\n  dragSobreContenedor(e) {\n    e.preventDefault();\n  }\n\n  onDropPlayer(e) {\n    const dragUSer = this.storage.getLocalStorage(\"me\", \"session\");\n    const avatarMobile = document.getElementById(e.dataTransfer.getData(\"userAvatar\"));\n    this.currentAvatar = avatarMobile;\n    this.roomBox.innerHTML =this.currentAvatar.outerHTML;    \n    avatarMobile.parentNode.removeChild(avatarMobile);\n    \n\n     if (this.players.length === this.capacity) {\n       this.isOpen = false;\n       this.disableRoom(this.id);\n       console.log(\"sala llena!\");\n       return;\n     }\n\n     if (this.players.length > this.capacity || !this.isOpen) {\n    //   console.log(\"La sala no acepta más jugadores\");\n       return;\n     }\n\n    this.addToRoom(dragUSer);\n  }\n\n  addToRoom(user) {\n    // Creamos jugador que recoge los datos del usuario arrastrado\n\n    console.log(\"user:\", user);\n\n    const draggedPlayer = {\n      name: user.name,\n      avatar: user.avatar,\n      id: user.id,\n    };\n\n    const rooms = this.storage.getLocalStorage(\"roomsList\").rooms;\n    const currentRoom = rooms.find((room) => room.id === this.id);\n    const restUsers = currentRoom.usersRoom.filter(\n      (userRoom) => userRoom.id !== draggedPlayer.id\n    );\n\n    // Si no existen usuarios en la sala\n    if (currentRoom.usersRoom.length === 0) {\n      currentRoom.usersRoom.push(draggedPlayer);\n      this.updatePlayers(currentRoom.usersRoom);\n    } else {\n      // Si no existe el usuario y ya hay usuarios en la sala\n      currentRoom.usersRoom = [...restUsers, draggedPlayer];\n      this.updatePlayers(currentRoom.usersRoom);\n    }\n\n    // Añadimos players a la room\n    this.players = currentRoom.usersRoom;\n\n    // Añadimos rooms actualizado al localStorage\n    const updateRooms = rooms.map((room) => {\n      if (room.id === this.id) {\n        room.usersRoom = currentRoom.usersRoom;\n      }\n      return room;\n    });\n    const updateRoomsList = {\n      eventType: EVENT_TYPES.ADD_USER_TO_ROOM,\n      roomEventId: this.id,\n      rooms: updateRooms,\n    };\n\n    this.storage.setLocalStorage(\"roomsList\", updateRoomsList);\n\n    // Mostramos panel superior sala\n    const gameTopPannelDiv = document.getElementById(\"gameTopPannel\");\n    gameTopPannelDiv.classList.remove(\"d-none\");\n    setTimeout(() => gameTopPannelDiv.classList.add(\"has-players\"), 1000);\n    gameTopPannelDiv.querySelector(\n      \".m-game__title strong\"\n    ).innerHTML = `${this.name}`;\n  }\n\n  updatePlayers(usersRoom) {\n    const roomBoxDiv = document.getElementById(this.id);\n    roomBoxDiv.querySelector(\".m-room-drop-item__total span\").innerHTML =\n      usersRoom.length;\n\n    // Actualizamos listado de los usarios conectados en el tablero\n    const listConnectedUSers = document.querySelector(\n      \"#roomConnectedMessage ul\"\n    );\n    const connectedUsers = usersRoom.map((user) => `<li>${user.name}</li>`);\n    listConnectedUSers.innerHTML = connectedUsers.join(\"\");\n\n    // Mostrar posibilidad de empezar a jugar\n    if (usersRoom.length > 1) {\n      this.renderPlayBtn();\n    }\n  }\n\n  showRoomMessage(type, user) {\n    let message;\n    const messageDiv = document.querySelector(\"#roomMessage\");\n    switch (type) {\n      case MESSAGE_TYPES.CONNECTED_TO_ROOM:\n        message = `El usuario ${user.name} se ha conectado a esta sala`;\n        break;\n      default:\n        return \"\";\n    }\n\n    const messageContentDiv = `<div class=\"alert alert-info alert-dismissible fade show\" role=\"alert\">\n                <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"alert\" aria-label=\"Close\"></button>\n                <span id=\"roomMessageContent\">${message}</span>\n              </div>`;\n    messageDiv.innerHTML = messageContentDiv;\n  }\n\n  disableRoom(id) {\n    const roomDivElement = document.getElementById(id);\n    roomDivElement.classList.add(\"isFull\");\n\n    // quitamos mensaje conectados del panel de juego\n    document.getElementById(\"roomConnectedMessage\").innerHTML = \"\";\n  }\n\n  takeOutFromRoom(player) {\n    let is_in = this.players.find(\n      (room_player) => room_player.id === player.id\n    );\n    if (!!is_in) {\n      this.game.takeOutFromGame(player);\n      //this.players = this.players.filter((room_player)=> room_player.id !== player.id);\n    }\n  }\n\n  initStorageEvents() {\n    window.addEventListener(\"storage\", (e) => {\n      // por cada sala se lanza este evento\n      if (e.key === \"roomsList\") {\n        const roomsList = JSON.parse(e.newValue);\n\n        switch (roomsList.eventType) {\n          case EVENT_TYPES.ADD_USER_TO_ROOM:\n            this.handleEventAddUser(roomsList);\n            break;\n          case EVENT_TYPES.PLAY_GAME:\n            this.handleEventPlayGame(roomsList);\n            break;\n          default:\n            return;\n        }\n      }\n    });\n  }\n\n  handleEventAddUser(roomsList) {\n    // Si la sala no es la que tiene el evento no hacemos nada\n    if (roomsList.roomEventId !== this.id) return;\n\n    const currentEventRoom = roomsList.rooms.find(\n      (room) => room.id === roomsList.roomEventId\n    );\n\n    // Actualizamos la información relacionada con el comienzo del juego en los otros jugadores\n    // caja de sala, mensaje de usuarios conectados en la sala\n    this.updatePlayers(currentEventRoom.usersRoom);\n  }\n\n  handleEventPlayGame(roomsList) {\n    // Si la sala no es la que tiene el evento no hacemos nada\n    if (roomsList.roomEventId !== this.id) return;\n    const currentRoom = roomsList.rooms.find(\n      (room) => room.id === roomsList.roomEventId\n    );\n    this.initGame(currentRoom.usersRoom, true);\n  }\n\n  renderPlayBtn() {\n    this.playButtonDiv.innerHTML = `<button class=\"btn btn-primary btn-lg btn-rounded px-4\" type=\"button\">Empezar a jugar!</button>`;\n    this.playButtonDiv.addEventListener(\"click\", this.playGame.bind(this));\n  }\n\n  playGame() {\n    const rooms = this.storage.getLocalStorage(\"roomsList\").rooms;\n    const updateRoomsStorage = rooms.map((room) => {\n      if (room.id === this.id) {\n        room.isOpen = false;\n      }\n      return room;\n    });\n\n    this.storage.setLocalStorage(\"roomsList\", {\n      eventType: EVENT_TYPES.PLAY_GAME,\n      roomEventId: this.id,\n      rooms: updateRoomsStorage,\n    });\n\n    const currentRoom = rooms.find((room) => room.id === this.id);\n    this.initGame(currentRoom.usersRoom);\n  }\n\n  prepareGame() {\n    // Quitamos botón de play\n    this.playButtonDiv.innerHTML = \"\";\n\n    // seteamos la room a close\n    this.isOpen = false;\n\n    // deshabilitamos sala\n    this.disableRoom(this.id);\n  }\n\n  initGame(players, isCallWithEvent = false) {\n    this.prepareGame(players);\n    // Inicializamos juego\n    const gridSize = 20;\n    const currentPlayerInfo = this.storage.getLocalStorage(\"me\", \"session\");\n    this.game = new Game(this.id, currentPlayerInfo, players, gridSize);\n    this.game.init(isCallWithEvent);\n  }\n}\n\nexport default Room;\n","export const MESSAGE_TYPES = {\n  CONNECTED_TO_ROOM: \"CONNECTED_TO_ROOM\",\n  DISCONNECTED_FROM_ROOM: \"DISCONNECTED_FROM_ROOM\",\n  WAITTING_TURN: \"WAITTING_TURN\",\n  HAS_LOST: \"HAS_LOST\",\n};\n\nexport const EVENT_TYPES = {\n  ADD_USER_TO_ROOM: \"ADD_USER_TO_ROOM\",\n  PLAY_GAME: \"PLAY_GAME\",\n  UPDATE_GAME: \"UPDATE_GAME\",\n  SOMEONE_HAS_LOST: \"SOMEONE_HAS_LOST\",\n};\n","export default class LocalStorage {\n  localStorage = window.localStorage;\n  sessionStorage = window.sessionStorage;\n\n  setLocalStorage(key, data, type) {\n    const dataToLocaltorage = JSON.stringify(data);\n    if (type === \"session\") {\n      this.sessionStorage.setItem(key, dataToLocaltorage);\n    } else {\n      this.localStorage.setItem(key, dataToLocaltorage);\n    }\n  }\n\n  getLocalStorage(key, type) {\n    let data;\n    if (type === \"session\") {\n      data = this.sessionStorage.getItem(key);\n    } else {\n      data = this.localStorage.getItem(key);\n    }\n\n    return JSON.parse(data);\n  }\n}\n\nexport const getNewGameInfo = (context) => {\n  return {\n    defeatedPlayers: context.defeatedPlayers,\n    grid: context.grid,\n    players: context.players,\n    round: context.round,\n    totalCellsToWin: context.totalCellsToWin,\n  };\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// extracted by mini-css-extract-plugin\nexport {};","import Game from \"./Game\";\nimport Room from \"./Room\";\nimport Dashboard from \"./DashBoard\";\nimport Register from \"./Register\";\nimport Login from \"./Login\";\n\nexport { Game, Room, Dashboard, Register, Login };\n"],"names":[],"sourceRoot":""}