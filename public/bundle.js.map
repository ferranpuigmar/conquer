<<<<<<< HEAD
{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;AAAA,+DAAe,cAAc,EAAE,UAAU,EAAE,eAAe,EAAE,gBAAgB,EAAE,UAAU,GAAG,yCAAyC;;;;;;;;;;;;;;ACApI;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AClBqC;AACrC;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,SAAS;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA,0gBAA0gB;AAC1gB;AACA;AACA;AACA;;AAEA,OAAO,wDAAQ;AACf;AACA;;AAEA;AACA;;AAEA,+DAAe,SAAS;;;;;;;;;;;;;AC7BG;AACY;;AAEvC;AACA;AACA,+CAA+C,+CAAG,KAAK;;AAEvD;AACA,mCAAmC;;AAEnC;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA;AACA;;AAEA,SAAS,yDAAS;AAClB;;AAEA,+DAAe,EAAE;;;;;;;;;;;;ACvBc;;AAE/B;AACA,qCAAqC,sDAAU;AAC/C;;AAEA,+DAAe,QAAQ;;;;;;;;;;;;ACNG;;AAE1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,6CAAI,gBAAgB,MAAM;;AAExD;;AAEA;AACA;;AAEA;AACA,kCAAkC,QAAQ;AAC1C;AACA,4BAA4B,UAAU;AACtC,sDAAsD,QAAQ;AAC9D;;;AAGA,KAAK;AACL;AACA;;AAEA,+DAAe,SAAS;;;;;;;;;;;ACnCxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,cAAc;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,MAAM,GAAG,KAAK;AAC3B,aAAa,IAAI,GAAG,OAAO;AAC3B,aAAa,MAAM,GAAG,KAAK;AAC3B,aAAa,IAAI,GAAG,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC,2BAA2B,YAAY,IAAI,aAAa;AACxD;AACA;AACA,iDAAiD,WAAW,GAAG,YAAY;AAC3E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA,6HAA6H;;AAE7H;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,+DAAe,IAAI;;;;;;;;;;;;ACnOgB;AACC;;AAEpC;;AAEA;AACA;AACA,cAAc,8CAAY;;AAE1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,EAAE;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO,sFAAsF;AAC7F,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,+DAAe,KAAK;;;;;;;;;;;ACrJpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+DAAe,MAAM;;;;;;;;;;;;;ACpBc;AACC;;AAEpC;;AAEA;AACA;AACA,cAAc,8CAAY;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD,EAAE;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO,sFAAsF;AAC7F,OAAO,+FAA+F;AACtG,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,UAAU,gDAAM;AAChB;AACA;AACA,oBAAoB,wDAAwD;AAC5E;AACA,mBAAmB,wDAAwD;AAC3E;;AAEA;AACA;AACA;;AAEA;;AAEA,+DAAe,QAAQ;;;;;;;;;;;ACtOvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA,+DAAe,IAAI;;;;;;;;;;;;;;AC9DJ;AACf;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;UCZA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA,8CAA8C;;;;;WCA9C;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNA;;;;;;;;;;;;;;;;;;;;;;;ACA0B;AACI;AACJ;AACU;AACF;AACN","sources":["webpack://Conquer/./node_modules/uuid/dist/esm-browser/regex.js","webpack://Conquer/./node_modules/uuid/dist/esm-browser/rng.js","webpack://Conquer/./node_modules/uuid/dist/esm-browser/stringify.js","webpack://Conquer/./node_modules/uuid/dist/esm-browser/v4.js","webpack://Conquer/./node_modules/uuid/dist/esm-browser/validate.js","webpack://Conquer/./src/js/DashBoard.js","webpack://Conquer/./src/js/Game.js","webpack://Conquer/./src/js/Login.js","webpack://Conquer/./src/js/Player.js","webpack://Conquer/./src/js/Register.js","webpack://Conquer/./src/js/Room.js","webpack://Conquer/./src/js/utils.js","webpack://Conquer/webpack/bootstrap","webpack://Conquer/webpack/runtime/define property getters","webpack://Conquer/webpack/runtime/hasOwnProperty shorthand","webpack://Conquer/webpack/runtime/make namespace object","webpack://Conquer/./src/sass/style.scss","webpack://Conquer/./src/js/index.js"],"sourcesContent":["export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import Room from \"./Room\";\n\nclass Dashboard{\n  rooms = [];\n\n  constructor(initData){\n    this.boxRooms = initData.boxRooms;\n  }\n\n  init(){\n    this.generateRooms();\n  }\n\n  generateRooms(){\n    this.boxRooms.forEach((box, index) => {\n      // Generamos las instancias de las salas\n      this.rooms[index] = new Room(box.id, `Room${index}`, 4);\n\n      const boxDiv = document.getElementById(box.id);\n\n      // Añadir evento en alguna parte del box para cuando se hace drag&drop\n      // Y que conecte con un método de la instancia de room\n\n      // Añadir clase para pintar caja\n      boxDiv.classList.add(`room${index+1}`);\n      // Añadir títulos\n      const title = `Room ${index + 1}`;\n      const boxDivHeader = document.querySelector(`#${box.id} .m-room-drop-item__header h3`);\n      boxDivHeader.innerHTML = title;\n\n\n    })\n  }\n}\n\nexport default Dashboard;","class Game\n{\n  colors = [ 'red', 'blue', 'green', 'brown' ];\n  grid = []\n  defeatedPlayers = [];\n  wrapper = \"\";\n  totalCellsToWin = 0;\n\n  constructor (\n    wrapper,\n    players,\n    gameSize\n  )\n  {\n    this.players = this.buildToGamePlayers( players );\n    this.gridSize = gameSize;\n    this.totalCells = gameSize * gameSize;\n    this.round = { turn: 1, roundNumber: 1, player: this.players[ 0 ] }\n    this.grid = this.generateGrid(gameSize);\n    this.wrapper = wrapper;\n  }\n\n  getPlayers ()\n  {\n    console.log( 'players: ', this.players );\n  }\n\n  getRoundInfo(){\n    const newTurn = this.round.turn + 1;\n    const isTurnEnd = newTurn > this.players.length;\n    const newRoundTitle = isTurnEnd ? this.round.roundNumber + 1 : this.round.roundNumber;\n\n    if(isTurnEnd){\n      const rountDivSection = document.querySelector('#roundTitle h3');\n      rountDivSection.innerHTML = `Round ${newRoundTitle}`\n    }\n\n    return {\n      roundNumber: newRoundTitle,\n      turn: isTurnEnd ? 1 : newTurn,\n      player: isTurnEnd ? this.players[0] : this.players[ newTurn - 1]\n    }\n  }\n\n  checkTurn ()\n  {\n    // Me descargo los updates del juego\n\n    // Seteo las propiedades del juego con esa info\n    this.round = this.getRoundInfo();\n  }\n\n  checkValidCellClick (cellObj, currentPlayer){\n    // row de la casilla clickada\n    const row = Number(cellObj.row);\n    // celda de la casilla clickada\n    const cell = Number(cellObj.cell);\n\n    // Generamos posibles celdas adjacentes que pueden ser del jugador\n    const nearCells = [\n      `cell${row+1}-${cell}`,\n      `cell${row}-${cell+1}`,\n      `cell${row-1}-${cell}`,\n      `cell${row}-${cell-1}`\n    ]\n    // Inicializamos un array para guardar las celdas \n    // adjacentes que pertenecen al jugador\n    const validClick = []\n\n    // Iteramos por el array de grid de nuestra clase Game para\n    // cotejar si las celdas que estan en nearCells tienen registrado al\n    // jugador, de modo que sabemos que son casillas en las que ha hecho click\n    // anteriormente\n    for(let i= 0; i < nearCells.length; i++){\n      // buscamos dentro de nuestro registro de grid la id de celda\n      const targetCell = this.grid.find(cell => cell.id === nearCells[i]);\n      // Si la celda existe en el gri y además está registrado a nombre del jugador\n      // añadimos una celda válida dentro de las posibles celdas adyacentes\n      if(targetCell && targetCell.playerId === currentPlayer.id){\n        validClick.push({validCell: true})\n      }\n    }\n\n    // Retornamos un valor booleanos que nos dice si almenos una\n    // de las casillas adjacentes a la casilla en la que se ha hecho click\n    // pertenece al jugador\n    return validClick.some(el => el.validCell)\n  }\n\n  checkCellClick ( e )\n  {\n    // chequeamos a que jugador le toca\n    const currentPlayerTurn = this.round.player;\n\n    // sacamos la id de la celda dentro del DOM\n    // sacamos los data asciados al número de row y la celda\n    const cellId = e.target.id;\n    const cellObj = {\n      row: e.target.dataset.row,\n      cell: e.target.dataset.cell\n    }\n    const cell = document.getElementById(cellId);\n\n    // comprobamos si es adjacente a la última seleccionada por el jugador\n    // siempre y cuando no sea el primer turno\n    if(this.round.roundNumber !== 1){\n      let isCellFilled, isAValidCellClick;\n      // comprobamos si está llena\n      isCellFilled = cell.classList.contains('isFilled')\n      // comprobamos si el click está en una casilla adjacente que pertenece al jugador\n      isAValidCellClick = this.checkValidCellClick(cellObj, currentPlayerTurn);\n\n      if(isCellFilled || !isAValidCellClick) {\n        return\n      };\n    }\n\n    // Añadimos la class isFilled que no permite pulsar la casilla\n    cell.classList.add('isFilled');\n    // Cambiamos la celda al color del jugador\n    cell.style.backgroundColor= currentPlayerTurn.color;\n    // Le sumamos 1 a sus casillas conquistadas\n    // y registramos la id de la celda como última posición\n    this.AddConqueredCell(currentPlayerTurn.id, cellId);\n\n    // Comprobamos si ha ganado\n    if(this.totalCellsToWin === currentPlayerTurn.cellsConquered){\n      console.log('El jugador 1 ha ganado!!!')\n    }\n\n    // cambiamos el turno\n    this.checkTurn()\n  }\n\n  AddConqueredCell(playerId, cellId){\n    this.players = this.players.map(player => {\n      if(player.id === playerId){\n        player.cellsConquered += 1;\n      }\n      return player;\n    })\n    this.grid.forEach(cell => {\n      if(cell.id === cellId){\n        cell.playerId = this.round.player.id\n      }\n    })\n  }\n\n  createDomGrid ()\n  {\n    const size = this.gridSize;\n    const wrapper = document.getElementById( this.wrapper );\n    let rowCounter = 1;\n    let cellCounter = 1;\n    let cells = []\n\n    for ( let i = 1; i <= size * size; i++ ) {\n      let cellId = `cell${ rowCounter }-${ cellCounter }`;\n      let cell = document.createElement( 'div' );\n      cell.id = cellId;\n      cell.className = `m-game-grid__cell cell-${rowCounter}-${cellCounter}`;\n      cell.dataset.cell = cellCounter;\n      cell.dataset.row = rowCounter;\n      cell.addEventListener( 'click', this.checkCellClick.bind( this ), false );\n      cells.push(cell);\n      cellCounter++;\n\n      // Si hay 20 celdas\n      if ( i % size === 0) {\n        // Creamos contenedor de la fila\n        let row = document.createElement( 'div' );\n        row.className = 'm-game-grid__row';\n\n        // Añadimos las 20 celdas a la fila\n        cells.forEach((cell, index) => {\n          row.appendChild(cell);\n        });\n\n        // Añadimos la fila al grid del HTML\n        wrapper.appendChild( row )\n\n        // Reiniciamos el array de celdas, \n        // el contador de celdas a 1 \n        // y añadimos 1 al contador de filas\n        cells = [];\n        cellCounter = 1;\n        rowCounter++;\n      }\n\n      // registamos la id de la casilla en nuestro registro de grid\n      this.grid[i-1] = {\n        id: cell.id,\n        playerId: null\n      }\n    }\n  }\n\n  generateGrid(gridSize){\n    return [...Array(gridSize * gridSize)]\n  }\n\n  buildToGamePlayers ( players )\n  {\n    return players.map( ( player, index ) => ( {\n      id: player.id,\n      name: player.getName(),\n      cellsConquered: 0,\n      color: this.colors[ index ]\n    } ) )\n  }\n\n  calculateTotalCellsToWin ( totalCells, players )\n  {\n    const numPlayers = players.length;\n    const otherConqueredCells = this.defeatedPlayers.reduce((acc, player) => acc.cellsConquered + player.cellsConquered, 0); // X casillas conquistadas por otros jugadores\n\n    this.totalCellsToWin =  Math.floor( (totalCells-otherConqueredCells) / numPlayers ) + 1\n  }\n\n  init(){\n    this.createDomGrid();\n    this.calculateTotalCellsToWin(this.totalCells, this.players)\n\n    // Generamos listener para manejar cambios en el localStorage\n  }\n}\n\nexport default Game;","import LocalStorage from \"./utils\";\nimport { v4 as uuidv4 } from 'uuid';\n\nclass Login {\n\n  fields = {}\n  errors = {}\n  local = new LocalStorage();\n\n  constructor(loginFields){\n    this.form = document.getElementById(loginFields.formId)\n    this.emailInput = document.getElementById(loginFields.emailId);\n    this.passwordInput = document.getElementById(loginFields.passwordId);\n    this.registerSubmitBtn = document.getElementById(loginFields.submtBtn);\n  }\n\n  validateEmail(name, element, value){\n    let message, isValid;\n\n    if(value === \"\"){\n      message = \"El email no puede estar vacío\"\n      isValid = false;\n    }\n\n    if(value !== \"\"){\n      const regex = /^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/;\n      isValid = regex.test(value);\n      message = isValid ? \"\" : \"El email no es válido\"\n    }\n\n    if(isValid) {\n      delete this.errors[name];\n      element.classList.remove('is-invalid')\n      document.getElementById(`${element.id}_error`).innerHTML = \"\";\n      this.fields[name].value = value;\n      return;\n    } else {\n      this.fields[name].value = '';\n    }\n\n    this.errors[name] = {\n      element: element,\n      message\n    }\n  }\n\n  validatePassword(name, element, value){\n\n    const isValid = value !== \"\";\n    const message = isValid ? '' : \"El password no puede estar vacío\";\n\n    if(isValid) {\n      delete this.errors[name];\n      element.classList.remove('is-invalid')\n      document.getElementById(`${element.id}_error`).innerHTML = \"\";\n      this.fields[name].value = value\n      return;\n    } else {\n      this.fields[name].value = '';\n    }\n\n    this.errors[name] = {\n      element: element,\n      message\n    }\n  }\n\n  registerLoginFields(){\n    const requiredFields = [\n      {name: 'emailInput', element: this.emailInput, validate: this.validateEmail.bind(this)},\n      {name: 'passwordInput', element: this.passwordInput, validate: this.validatePassword.bind(this)}\n    ]\n    requiredFields.forEach(field => {\n      this.fields[field.name] = {\n        name: field.name,\n        validate: field.validate,\n        element: field.element,\n        value: ''\n      }\n    })\n  }\n\n  assignListeners(){\n    this.form.addEventListener('submit', this.send.bind(this));\n  }\n\n  init(){\n    this.registerLoginFields();\n    this.assignListeners();\n  }\n\n  loginUser(data){\n    const allUSers = this.local.getLocalStorage('users');\n\n    const user = allUSers.find(user => user.email === newUser.email);\n    if(!user){\n      this.showErrorMessage(\"No existe nadie con este email\")\n      return;\n    }\n    const passWordIsValid = allUSers.find(user => user.password === newUser.password);\n    if(!passWordIsValid){\n      this.showErrorMessage(\"La contraseña no es válida\")\n      return;\n    }\n\n    // Aqui va la lógica para poner al \"user\" (línea 95) dentro de los usuarios conectados\n    // También se tiene que redirigir al usuario a la ruta /rooms\n  }\n\n  showErrorMessage(message){\n    const messageElement = document.getElementById('errorMessage');\n    messageElement.innerHTML = message;\n    messageElement.classList.remove('d-none');\n  }\n\n  send(e){\n    e.preventDefault();\n    const fields = this.fields;\n\n    const errorMessageElement = document.getElementById('errorMessage');\n    errorMessageElement.classList.add('d-none');\n\n    Object.keys(fields).forEach(field => {\n      this.fields[field].validate(fields[field].name, fields[field].element, fields[field].element.value)\n    })\n\n    const existErrors = Object.keys(this.errors).length !== 0;\n\n    if(existErrors){\n      Object.keys(this.errors).forEach(error => {\n        const inputElement = this.errors[error].element;\n        const msgErrorElement = `${inputElement.id}_error`;\n        inputElement.classList.add('is-invalid');\n        document.getElementById(msgErrorElement).innerHTML = this.errors[error].message;\n      })\n      return;\n    }\n\n    const data  = {\n      email: this.fields.emailInput.value,\n      password: this.fields.passwordInput.value,\n    };\n\n    // Método para enviar la información al localStorage, al apartado de usuaros conectados\n    this.loginUser(data);\n  }\n\n}\n\nexport default Login;","class Player {\n  constructor(\n    id,\n    name,\n    avatar\n  ){\n    this.id = id;\n    this.name = name;\n    this.avatar = avatar;\n  }\n\n  getName(){\n    return this.name;\n  }\n\n  getAvatar(){\n    return this.avatar;\n  }\n}\n\nexport default Player;","import LocalStorage from \"./utils\";\nimport { v4 as uuidv4 } from 'uuid';\n\nclass Register {\n\n  fields = {}\n  errors = {}\n  local = new LocalStorage();\n\n  constructor(registerFields){\n    this.form = document.getElementById(registerFields.formId)\n    this.emailInput = document.getElementById(registerFields.emailId);\n    this.passwordInput = document.getElementById(registerFields.passwordId);\n    this.favouriteRoom = document.getElementById(registerFields.favouriteRoomId);\n    this.avatarWrapper = document.getElementById(registerFields.avatarWrapperId);\n    this.registerSubmitBtn = document.getElementById(registerFields.submtBtn);\n  }\n\n  onSelectAvatar(e){\n    const avatarId = e.target.id;\n    const avatarDiv = document.getElementById(avatarId);\n    this.selectAvatar(avatarDiv)\n  }\n\n  selectAvatar(selected){\n    const avatars = this.avatarWrapper.querySelectorAll('.a-avatar');\n    avatars.forEach(avatar => {\n      avatar.classList.remove('active')\n    })\n\n    selected.classList.add('active');\n  }\n\n  assignListeners(){\n    const avatars = this.avatarWrapper.querySelectorAll('.a-avatar');\n    avatars.forEach(avatar => {\n      avatar.addEventListener('click', this.onSelectAvatar.bind(this));\n    })\n\n    this.form.addEventListener('submit', this.send.bind(this));\n  }\n\n  resetForm(){\n    for(let field in this.fields){\n      const fieldEl = this.fields[field];\n      fieldEl.value = \"\";\n      if(fieldEl.name === 'favouriteRoom'){\n        fieldEl.element.value = \"0\"\n      } else {\n        fieldEl.element.value = \"\";\n      }\n    }\n\n    const defaultAvatar = document.getElementById('avatar1');\n    this.selectAvatar(defaultAvatar)\n  }\n\n  validateEmail(name, element, value){\n    let message, isValid;\n\n    if(value === \"\"){\n      message = \"El email no puede estar vacío\"\n      isValid = false;\n    }\n\n    if(value !== \"\"){\n      const regex = /^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/;\n      isValid = regex.test(value);\n      message = isValid ? \"\" : \"El email no es válido\"\n    }\n\n    if(isValid) {\n      delete this.errors[name];\n      element.classList.remove('is-invalid')\n      document.getElementById(`${element.id}_error`).innerHTML = \"\";\n      this.fields[name].value = value;\n      return;\n    } else {\n      this.fields[name].value = '';\n    }\n\n    this.errors[name] = {\n      element: element,\n      message\n    }\n  }\n\n  validatePassword(name, element, value){\n\n    const isValid = value !== \"\";\n    const message = isValid ? '' : \"El password no puede estar vacío\";\n\n    if(isValid) {\n      delete this.errors[name];\n      element.classList.remove('is-invalid')\n      document.getElementById(`${element.id}_error`).innerHTML = \"\";\n      this.fields[name].value = value\n      return;\n    } else {\n      this.fields[name].value = '';\n    }\n\n    this.errors[name] = {\n      element: element,\n      message\n    }\n  }\n\n  validateFavouriteRoom(name, element, value){\n    const isValid = value !== \"0\";\n    const message = isValid ? '' : \"Debes seleccionar una sala\";\n\n    if(isValid) {\n      delete this.errors[name];\n      element.classList.remove('is-invalid')\n      document.getElementById(`${element.id}_error`).innerHTML = \"\";\n      this.fields[name].value = value;\n      return;\n    } else {\n      this.fields[name].value = '';\n    }\n\n    this.errors[name] = {\n      element: element,\n      message\n    }\n  }\n\n  registerFields(){\n    const requiredFields = [\n      {name: 'emailInput', element: this.emailInput, validate: this.validateEmail.bind(this)},\n      {name: 'passwordInput', element: this.passwordInput, validate: this.validatePassword.bind(this)},\n      {name: 'favouriteRoom', element: this.favouriteRoom, validate: this.validateFavouriteRoom.bind(this)}\n    ]\n    requiredFields.forEach(field => {\n      this.fields[field.name] = {\n        name: field.name,\n        validate: field.validate,\n        element: field.element,\n        value: ''\n      }\n    })\n  }\n\n  init(){\n    this.assignListeners();\n    this.registerFields();\n  }\n\n  saveUser(data){\n    const allUSers = this.local.getLocalStorage('users');\n    const newUser = data;\n\n    if(!allUSers || allUSers.length === 0){\n      this.local.setLocalStorage('users', [newUser])\n      return;\n    }\n\n    const existUSer = allUSers.find(user => user.email === newUser.email);\n    if(existUSer){\n      this.showErrorMessage(\"Ya existe un usuario con este email\")\n      return;\n    }\n\n    allUSers.push(newUser);\n    this.local.setLocalStorage('users', allUSers)\n    this.resetForm();\n    this.showSuccesMessage();\n  }\n\n  showErrorMessage(message){\n    const messageElement = document.getElementById('errorMessage');\n    messageElement.innerHTML = message;\n    messageElement.classList.remove('d-none');\n  }\n\n  showSuccesMessage(){\n    const message = \"Tu usuario se ha registrado correctamente.\";\n    const messageElement = document.getElementById('successMessage');\n    const loginButton = document.getElementById('successButton');\n    const submitButton = document.getElementById('submitButton');\n    messageElement.innerHTML = message;\n    messageElement.classList.remove('d-none');\n    loginButton.classList.remove('d-none');\n    submitButton.classList.add('d-none');\n\n    setTimeout(()=> {\n      messageElement.classList.add('d-none');\n      submitButton.classList.remove('d-none');\n    }, 2000)\n  }\n\n  send(e){\n    e.preventDefault();\n    const fields = this.fields;\n\n    const errorMessageElement = document.getElementById('errorMessage');\n    errorMessageElement.classList.add('d-none');\n\n    Object.keys(fields).forEach(field => {\n      this.fields[field].validate(fields[field].name, fields[field].element, fields[field].element.value)\n    })\n\n    const existErrors = Object.keys(this.errors).length !== 0;\n\n    if(existErrors){\n      Object.keys(this.errors).forEach(error => {\n        const inputElement = this.errors[error].element;\n        const msgErrorElement = `${inputElement.id}_error`;\n        inputElement.classList.add('is-invalid');\n        document.getElementById(msgErrorElement).innerHTML = this.errors[error].message;\n      })\n      return;\n    }\n\n    const data  = {\n      id: uuidv4(),\n      email: this.fields.emailInput.value,\n      password: this.fields.passwordInput.value,\n      avatar: `mod${this.avatarWrapper.querySelector('.active').dataset.mod}`,\n      favouriteRoom: this.fields.favouriteRoom.value,\n      color: `mod${this.avatarWrapper.querySelector('.active').dataset.mod}`\n    };\n\n    // Evento para enviar la información al localStorage, al apartado de usuaros registrados\n    this.saveUser(data);\n  }\n\n}\n\nexport default Register;","class Room {\n  capacity = 4;\n  isOpen = true;\n  players = [];\n  roomBox = \"\";\n  game = \"\";\n\n  constructor(id, name, capacity){\n    this.id = id;\n    this.name = name;\n    this.capacity = capacity;\n  }\n\n  onDraggPlayer(user){\n\n    if(this.players.length === this.capacity){\n      this.isOpen = false;\n      disableRoom(this.id)\n      console.log('sala llena!')\n      return;\n    }\n\n    if(this.players.length > this.capacity || !this.isOpen){\n      console.log('La sala no acepta más jugadores')\n      return;\n    }\n\n    this.addToRoom(user);\n  }\n\n  addToRoom(user){\n    // Creamos jugador que recoge los datos del usuario arrastrado\n    const draggedPlayer = new Player(user.id, user.name, user.avatar);\n    this.players.push(draggedPlayer)\n    // Mostrar mensaje que se ha añadido un nuevo jugador\n\n    if(this.players > 1){\n      // Mostrar posibilidad de empezar a jugar\n    }\n  }\n\n  disableRoom(id){\n    const roomDivElement = document.getElementById(id);\n    roomDivElement.classList.add('isFull');\n  }\n\n  getPlayers(){\n    return players;\n  }\n\n  initGame(){\n    // Quitamos botón de play\n\n    // Inicializamos juego\n    const gridSize = 20;\n    this.game = Game('grid', this.players, gridSize);\n    this.game.init();\n  }\n\n\n}\n\nexport default Room;","export default class LocalStorage {\n  localStorage = window.localStorage;\n\n  setLocalStorage(key, data, type){\n    const dataToLocaltorage = JSON.stringify(data);\n    this.localStorage.setItem(key, dataToLocaltorage)\n  }\n\n  getLocalStorage(key){\n    const data = this.localStorage.getItem(key);\n    return JSON.parse(data);\n  }\n}","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// extracted by mini-css-extract-plugin\nexport {};","import Game from './Game';\nimport Player from './Player';\nimport Room from './Room';\nimport Dashboard from './DashBoard';\nimport Register from './Register';\nimport Login from './Login';\n\nexport {\n  Game,\n  Player,\n  Room,\n  Dashboard,\n  Register,\n  Login\n}"],"names":[],"sourceRoot":""}
=======
{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;;;;;AAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6CAAI,gBAAgB,MAAM;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA,4BAA4B,UAAU;AACtC,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,iEAAe,SAAS;;;;;;;;;;;;;;ACnCxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM,GAAG,KAAK;AAC3B,aAAa,IAAI,GAAG,OAAO;AAC3B,aAAa,MAAM,GAAG,KAAK;AAC3B,aAAa,IAAI,GAAG,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX;AACA;AACA,iBAAiB;AACjB,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC,2BAA2B,YAAY,IAAI,aAAa;AACxD;AACA;AACA;AACA;AACA,iDAAiD,WAAW,GAAG,YAAY;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,6HAA6H;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,IAAI;;;;;;;;;;;;;;AC7QnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,MAAM;;;;;;;;;;;;;;ACpBrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,IAAI;;;;;;UC9DnB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNA;;;;;;;;;;;;;;;;;;;;ACA0B;AACI;AACJ;AACU;AACpC","sources":["webpack://Conquer/./src/js/DashBoard.js","webpack://Conquer/./src/js/Game.js","webpack://Conquer/./src/js/Player.js","webpack://Conquer/./src/js/Room.js","webpack://Conquer/webpack/bootstrap","webpack://Conquer/webpack/runtime/define property getters","webpack://Conquer/webpack/runtime/hasOwnProperty shorthand","webpack://Conquer/webpack/runtime/make namespace object","webpack://Conquer/./src/sass/style.scss?3ac4","webpack://Conquer/./src/js/index.js"],"sourcesContent":["import Room from \"./Room\";\r\n\r\nclass Dashboard{\r\n  rooms = [];\r\n\r\n  constructor(initData){\r\n    this.boxRooms = initData.boxRooms;\r\n  }\r\n\r\n  init(){\r\n    this.generateRooms();\r\n  }\r\n\r\n  generateRooms(){\r\n    this.boxRooms.forEach((box, index) => {\r\n      // Generamos las instancias de las salas\r\n      this.rooms[index] = new Room(box.id, `Room${index}`, 4);\r\n\r\n      const boxDiv = document.getElementById(box.id);\r\n\r\n      // Añadir evento en alguna parte del box para cuando se hace drag&drop\r\n      // Y que conecte con un método de la instancia de room\r\n\r\n      // Añadir clase para pintar caja\r\n      boxDiv.classList.add(`room${index+1}`);\r\n      // Añadir títulos\r\n      const title = `Room ${index + 1}`;\r\n      const boxDivHeader = document.querySelector(`#${box.id} .m-room-drop-item__header h3`);\r\n      boxDivHeader.innerHTML = title;\r\n\r\n\r\n    })\r\n  }\r\n}\r\n\r\nexport default Dashboard;","class Game\r\n{\r\n  colors = [ 'red', 'blue', 'green', 'brown' ];\r\n  grid = []\r\n  defeatedPlayers = [];\r\n  wrapper = \"\";\r\n  totalCellsToWin = 0;\r\n\r\n  constructor (\r\n    wrapper,\r\n    players,\r\n    gameSize\r\n  )\r\n  {\r\n    this.players = this.buildToGamePlayers( players );\r\n    this.gridSize = gameSize;\r\n    this.totalCells = gameSize * gameSize;\r\n    this.round = { turn: 1, roundNumber: 1, player: this.players[ 0 ] }\r\n    this.grid = this.generateGrid(gameSize);\r\n    this.wrapper = wrapper;\r\n  }\r\n\r\n  getPlayers ()\r\n  {\r\n    console.log( 'players: ', this.players );\r\n  }\r\n\r\n  getRoundInfo(){\r\n    const newTurn = this.round.turn + 1;\r\n    const isTurnEnd = newTurn > this.players.length;\r\n    const newRoundTitle = isTurnEnd ? this.round.roundNumber + 1 : this.round.roundNumber;\r\n\r\n    if(isTurnEnd){\r\n      const rountDivSection = document.querySelector('#roundTitle h3');\r\n      rountDivSection.innerHTML = `Round ${newRoundTitle}`\r\n    }\r\n\r\n    return {\r\n      roundNumber: newRoundTitle,\r\n      turn: isTurnEnd ? 1 : newTurn,\r\n      player: isTurnEnd ? this.players[0] : this.players[ newTurn - 1]\r\n    }\r\n  }\r\n\r\n  checkTurn ()\r\n  {\r\n    // Me descargo los updates del juego\r\n\r\n    // Seteo las propiedades del juego con esa info\r\n    this.round = this.getRoundInfo();\r\n  }\r\n\r\n  checkValidCellClick (cellObj, id){\r\n    // row de la casilla clickada\r\n    const row = Number(cellObj.row);\r\n    // celda de la casilla clickada\r\n    const cell = Number(cellObj.cell);\r\n\r\n    // Generamos posibles celdas adjacentes que pueden ser del jugador\r\n    const nearCells = [\r\n      `cell${row+1}-${cell}`,\r\n      `cell${row}-${cell+1}`,\r\n      `cell${row-1}-${cell}`,\r\n      `cell${row}-${cell-1}`\r\n    ]\r\n    // Inicializamos un array para guardar las celdas \r\n    // adjacentes que pertenecen al jugador\r\n    const validClick = []\r\n\r\n    // Iteramos por el array de grid de nuestra clase Game para\r\n    // cotejar si las celdas que estan en nearCells tienen registrado al\r\n    // jugador, de modo que sabemos que son casillas en las que ha hecho click\r\n    // anteriormente\r\n    for(let i= 0; i < nearCells.length; i++){\r\n      // buscamos dentro de nuestro registro de grid la id de celda\r\n      const targetCell = this.grid.find(cell => cell.id === nearCells[i]);\r\n      // Si la celda existe en el gri y además está registrado a nombre del jugador\r\n      // añadimos una celda válida dentro de las posibles celdas adyacentes\r\n      if(targetCell && targetCell.playerId === id){\r\n        validClick.push({validCell: true})\r\n      }\r\n    }\r\n\r\n    // Retornamos un valor booleanos que nos dice si almenos una\r\n    // de las casillas adjacentes a la casilla en la que se ha hecho click\r\n    // pertenece al jugador\r\n    return validClick.some(el => el.validCell)\r\n  }\r\n\r\n  checkCellClick ( e )\r\n  {\r\n    // chequeamos a que jugador le toca\r\n    const currentPlayerTurn = this.round.player;\r\n\r\n    // sacamos la id de la celda dentro del DOM\r\n    // sacamos los data asciados al número de row y la celda\r\n    const cellId = e.target.id;\r\n    const cellObj = {\r\n      row: e.target.dataset.row,\r\n      cell: e.target.dataset.cell\r\n    }\r\n    const cell = document.getElementById(cellId);\r\n\r\n    // comprobamos si es adjacente a la última seleccionada por el jugador\r\n    // siempre y cuando no sea el primer turno\r\n    if(this.round.roundNumber !== 1){\r\n      let isCellFilled, isAValidCellClick;\r\n      // comprobamos si está llena\r\n      isCellFilled = cell.classList.contains('isFilled')\r\n      // comprobamos si el click está en una casilla adjacente que pertenece al jugador\r\n      isAValidCellClick = this.checkValidCellClick(cellObj, currentPlayerTurn.id);\r\n\r\n      if(isCellFilled || !isAValidCellClick) {\r\n        return\r\n      };\r\n    }\r\n\r\n    // Añadimos la class isFilled que no permite pulsar la casilla\r\n    cell.classList.add('isFilled');\r\n    // Cambiamos la celda al color del jugador\r\n    cell.style.backgroundColor= currentPlayerTurn.color;\r\n    // Le sumamos 1 a sus casillas conquistadas\r\n    // y registramos la id de la celda como última posición\r\n    this.AddConqueredCell(currentPlayerTurn.id, cellId);\r\n\r\n    // Comprobamos que ninguno de los otros jugadores \r\n    // ha perdido.\r\n    this.checkOtherPlayerLoss(currentPlayerTurn.id);\r\n\r\n    // Comprobamos si ha ganado\r\n    if(this.totalCellsToWin === currentPlayerTurn.cellsConquered || this.players.length == 1){\r\n      console.log(`El jugador ${currentPlayerTurn.name} ha ganado!!!`);\r\n    }\r\n\r\n    // cambiamos el turno\r\n    this.checkTurn()\r\n  }\r\n\r\n  checkOtherPlayerLoss(currentPlayerId){\r\n      console.log(currentPlayerId);\r\n      let otherPlayers = this.players.filter((o)=> o.id !== currentPlayerId);\r\n      let defeated = [];\r\n      otherPlayers.forEach((player) => {\r\n        let aux = true;\r\n        console.log(player);\r\n          let conqueredCells = this.grid.filter((c)=> c.playerId == player.id);\r\n\r\n          if(conqueredCells.length > 0){\r\n            conqueredCells.forEach((cellObj)=>{\r\n              console.log(cellObj);\r\n              if(this.checkValidCellClick(cellObj, null)){\r\n                aux = false;\r\n              }\r\n            })\r\n          }else{\r\n            aux= false;\r\n          }\r\n        if(aux){ defeated.push(player); };\r\n      });\r\n\r\n      if(defeated.length > 0){\r\n        defeated.forEach((player)=>{\r\n          console.log(player);\r\n          this.defeatedPlayers.push(player);\r\n          this.players = this.players.filter(oplayer => oplayer.id !== player.id);\r\n        });\r\n\r\n        return true;\r\n      }\r\n      return false;\r\n  }\r\n\r\n  AddConqueredCell(playerId, cellId){\r\n    this.players = this.players.map(player => {\r\n      if(player.id === playerId){\r\n        player.cellsConquered += 1;\r\n      }\r\n      return player;\r\n    })\r\n    this.grid.forEach(cell => {\r\n      if(cell.id === cellId){\r\n        cell.playerId = this.round.player.id\r\n      }\r\n    })\r\n  }\r\n\r\n  createDomGrid ()\r\n  {\r\n    const size = this.gridSize;\r\n    const wrapper = document.getElementById( this.wrapper );\r\n    let rowCounter = 1;\r\n    let cellCounter = 1;\r\n    let cells = []\r\n\r\n    for ( let i = 1; i <= size * size; i++ ) {\r\n      let cellId = `cell${ rowCounter }-${ cellCounter }`;\r\n      let cell = document.createElement( 'div' );\r\n      cell.id = cellId;\r\n      cell.row = rowCounter;\r\n      cell.cell = cellCounter;\r\n      cell.className = `m-game-grid__cell cell-${rowCounter}-${cellCounter}`;\r\n      cell.dataset.cell = cellCounter;\r\n      cell.dataset.row = rowCounter;\r\n      cell.addEventListener( 'click', this.checkCellClick.bind( this ), false );\r\n      cells.push(cell);\r\n      cellCounter++;\r\n\r\n      // Si hay 20 celdas\r\n      if ( i % size === 0) {\r\n        // Creamos contenedor de la fila\r\n        let row = document.createElement( 'div' );\r\n        row.className = 'm-game-grid__row';\r\n\r\n        // Añadimos las 20 celdas a la fila\r\n        cells.forEach((cell, index) => {\r\n          row.appendChild(cell);\r\n        });\r\n\r\n        // Añadimos la fila al grid del HTML\r\n        wrapper.appendChild( row )\r\n\r\n        // Reiniciamos el array de celdas, \r\n        // el contador de celdas a 1 \r\n        // y añadimos 1 al contador de filas\r\n        cells = [];\r\n        cellCounter = 1;\r\n        rowCounter++;\r\n      }\r\n\r\n      // registamos la id de la casilla en nuestro registro de grid\r\n      this.grid[i-1] = {\r\n        id: cell.id,\r\n        row: cell.row,\r\n        cell: cell.cell,\r\n        playerId: null\r\n      }\r\n    }\r\n  }\r\n\r\n  generateGrid(gridSize){\r\n    return [...Array(gridSize * gridSize)]\r\n  }\r\n\r\n  buildToGamePlayers ( players )\r\n  {\r\n    return players.map( ( player, index ) => ( {\r\n      id: player.id,\r\n      name: player.getName(),\r\n      cellsConquered: 0,\r\n      color: this.colors[ index ]\r\n    } ) )\r\n  }\r\n\r\n  calculateTotalCellsToWin ( totalCells, players )\r\n  {\r\n    const numPlayers = players.length;\r\n    const otherConqueredCells = this.defeatedPlayers.reduce((acc, player) => acc.cellsConquered + player.cellsConquered, 0); // X casillas conquistadas por otros jugadores\r\n\r\n    this.totalCellsToWin =  Math.floor( (totalCells-otherConqueredCells) / numPlayers ) + 1\r\n  }\r\n\r\n  init(){\r\n    this.createDomGrid();\r\n    this.calculateTotalCellsToWin(this.totalCells, this.players)\r\n\r\n    // Generamos listener para manejar cambios en el localStorage\r\n  }\r\n}\r\n\r\nexport default Game;","class Player {\r\n  constructor(\r\n    id,\r\n    name,\r\n    avatar\r\n  ){\r\n    this.id = id;\r\n    this.name = name;\r\n    this.avatar = avatar;\r\n  }\r\n\r\n  getName(){\r\n    return this.name;\r\n  }\r\n\r\n  getAvatar(){\r\n    return this.avatar;\r\n  }\r\n}\r\n\r\nexport default Player;","class Room {\r\n  capacity = 4;\r\n  isOpen = true;\r\n  players = [];\r\n  roomBox = \"\";\r\n  game = \"\";\r\n\r\n  constructor(id, name, capacity){\r\n    this.id = id;\r\n    this.name = name;\r\n    this.capacity = capacity;\r\n  }\r\n\r\n  onDraggPlayer(user){\r\n\r\n    if(this.players.length === this.capacity){\r\n      this.isOpen = false;\r\n      disableRoom(this.id)\r\n      console.log('sala llena!')\r\n      return;\r\n    }\r\n\r\n    if(this.players.length > this.capacity || !this.isOpen){\r\n      console.log('La sala no acepta más jugadores')\r\n      return;\r\n    }\r\n\r\n    this.addToRoom(user);\r\n  }\r\n\r\n  addToRoom(user){\r\n    // Creamos jugador que recoge los datos del usuario arrastrado\r\n    const draggedPlayer = new Player(user.id, user.name, user.avatar);\r\n    this.players.push(draggedPlayer)\r\n    // Mostrar mensaje que se ha añadido un nuevo jugador\r\n\r\n    if(this.players > 1){\r\n      // Mostrar posibilidad de empezar a jugar\r\n    }\r\n  }\r\n\r\n  disableRoom(id){\r\n    const roomDivElement = document.getElementById(id);\r\n    roomDivElement.classList.add('isFull');\r\n  }\r\n\r\n  getPlayers(){\r\n    return players;\r\n  }\r\n\r\n  initGame(){\r\n    // Quitamos botón de play\r\n\r\n    // Inicializamos juego\r\n    const gridSize = 20;\r\n    this.game = Game('grid', this.players, gridSize);\r\n    this.game.init();\r\n  }\r\n\r\n\r\n}\r\n\r\nexport default Room;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// extracted by mini-css-extract-plugin\nexport {};","import Game from './Game';\r\nimport Player from './Player';\r\nimport Room from './Room';\r\nimport Dashboard from './DashBoard';\r\n\r\nexport {\r\n  Game, \r\n  Player,\r\n  Room,\r\n  Dashboard\r\n}"],"names":[],"sourceRoot":""}
>>>>>>> develop
