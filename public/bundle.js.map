{"version":3,"file":"bundle.js","mappings":";;;;;;;;;;;;AAAA,+DAAe,cAAc,EAAE,UAAU,EAAE,eAAe,EAAE,gBAAgB,EAAE,UAAU,GAAG,yCAAyC;;;;;;;;;;;;;;ACApI;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AClBqC;AACrC;AACA;AACA;AACA;;AAEA;;AAEA,gBAAgB,SAAS;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA,0gBAA0gB;AAC1gB;AACA;AACA;AACA;;AAEA,OAAO,wDAAQ;AACf;AACA;;AAEA;AACA;;AAEA,+DAAe,SAAS;;;;;;;;;;;;;AC7BG;AACY;;AAEvC;AACA;AACA,+CAA+C,+CAAG,KAAK;;AAEvD;AACA,mCAAmC;;AAEnC;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA;AACA;;AAEA,SAAS,yDAAS;AAClB;;AAEA,+DAAe,EAAE;;;;;;;;;;;;ACvBc;;AAE/B;AACA,qCAAqC,sDAAU;AAC/C;;AAEA,+DAAe,QAAQ;;;;;;;;;;;ACNvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA,4BAA4B,UAAU;AACtC,sDAAsD,QAAQ;AAC9D;AACA,KAAK;AACL;AACA;;AAEA,+DAAe,SAAS;;;;;;;;;;;;;ACtBY;;AAEpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,cAAc;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,MAAM,GAAG,KAAK;AAC3B,aAAa,IAAI,GAAG,OAAO;AAC3B,aAAa,MAAM,GAAG,KAAK;AAC3B,aAAa,IAAI,GAAG,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC,2BAA2B,YAAY,IAAI,aAAa;AACxD;AACA;AACA,iDAAiD,WAAW,GAAG,YAAY;AAC3E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,gDAAM;AAChB;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+DAAe,IAAI;;;;;;;;;;;AC/NnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+DAAe,MAAM;;;;;;;;;;;ACrBe;;AAEpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,+DAAe,IAAI;;;;;;UCvBnB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA,8CAA8C;;;;;WCA9C;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACNA;;;;;;;;;;;;;;;;;;;ACA0B;AACI;AACJ;AACU","sources":["webpack://Conquer/./node_modules/uuid/dist/esm-browser/regex.js","webpack://Conquer/./node_modules/uuid/dist/esm-browser/rng.js","webpack://Conquer/./node_modules/uuid/dist/esm-browser/stringify.js","webpack://Conquer/./node_modules/uuid/dist/esm-browser/v4.js","webpack://Conquer/./node_modules/uuid/dist/esm-browser/validate.js","webpack://Conquer/./src/js/DashBoard.js","webpack://Conquer/./src/js/Game.js","webpack://Conquer/./src/js/Player.js","webpack://Conquer/./src/js/Room.js","webpack://Conquer/webpack/bootstrap","webpack://Conquer/webpack/runtime/define property getters","webpack://Conquer/webpack/runtime/hasOwnProperty shorthand","webpack://Conquer/webpack/runtime/make namespace object","webpack://Conquer/./src/sass/style.scss?3ac4","webpack://Conquer/./src/js/index.js"],"sourcesContent":["export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","class Dashboard{\n  constructor(initData){\n    this.boxRooms = initData.boxRooms;\n  }\n\n  init(){\n    this.generateRoomBoxes();\n  }\n\n  generateRoomBoxes(){\n    this.boxRooms.forEach((box, index) => {\n\n      const boxDiv = document.getElementById(box.id);\n      // Añadir clase para pintar caja\n      boxDiv.classList.add(`room${index+1}`);\n      // Añadir títulos\n      const title = `Room ${index + 1}`;\n      const boxDivHeader = document.querySelector(`#${box.id} .m-room-drop-item__header h3`);\n      boxDivHeader.innerHTML = title;\n    })\n  }\n}\n\nexport default Dashboard;","\nimport { v4 as uuidv4 } from 'uuid';\n\nclass Game\n{\n  colors = [ 'red', 'blue', 'green', 'brown' ];\n  grid = []\n  wrapper = \"\";\n\n  constructor (\n    wrapper,\n    players,\n    gameSize\n  )\n  {\n    this.players = this.buildToGamePlayers( players );\n    this.gridSize = gameSize;\n    this.totalCells = gameSize * gameSize;\n    this.totalCellsToWin = this.calculateTotalCellsToWin( this.totalCells, this.players )\n    this.round = { turn: 1, roundNumber: 1, player: this.players[ 0 ] }\n    this.grid = this.generateGrid(gameSize);\n    this.wrapper = wrapper;\n  }\n\n  getPlayers ()\n  {\n    console.log( 'players: ', this.players );\n  }\n\n  getRoundInfo(){\n    const newTurn = this.round.turn + 1;\n    const isTurnEnd = newTurn > this.players.length;\n    const newRoundTitle = isTurnEnd ? this.round.roundNumber + 1 : this.round.roundNumber;\n\n    if(isTurnEnd){\n      const rountDivSection = document.querySelector('#roundTitle h3');\n      rountDivSection.innerHTML = `Round ${newRoundTitle}`\n    }\n\n    return {\n      roundNumber: newRoundTitle,\n      turn: isTurnEnd ? 1 : newTurn,\n      player: isTurnEnd ? this.players[0] : this.players[ newTurn - 1]\n    }\n  }\n\n  checkTurn ()\n  {\n    this.round = this.getRoundInfo();\n  }\n\n  checkValidCellClick (cellObj, currentPlayer){\n    // row de la casilla clickada\n    const row = Number(cellObj.row);\n    // celda de la casilla clickada\n    const cell = Number(cellObj.cell);\n\n    // Generamos posibles celdas adjacentes que pueden ser del jugador\n    const nearCells = [\n      `cell${row+1}-${cell}`,\n      `cell${row}-${cell+1}`,\n      `cell${row-1}-${cell}`,\n      `cell${row}-${cell-1}`\n    ]\n    // Inicializamos un array para guardar las celdas \n    // adjacentes que pertenecen al jugador\n    const validClick = []\n\n    // Iteramos por el array de grid de nuestra clase Game para\n    // cotejar si las celdas que estan en nearCells tienen registrado al\n    // jugador, de modo que sabemos que son casillas en las que ha hecho click\n    // anteriormente\n    for(let i= 0; i < nearCells.length; i++){\n      // buscamos dentro de nuestro registro de grid la id de celda\n      const targetCell = this.grid.find(cell => cell.id === nearCells[i]);\n      // Si la celda existe en el gri y además está registrado a nombre del jugador\n      // añadimos una celda válida dentro de las posibles celdas adyacentes\n      if(targetCell && targetCell.playerId === currentPlayer.id){\n        validClick.push({validCell: true})\n      }\n    }\n\n    // Retornamos un valor booleanos que nos dice si almenos una\n    // de las casillas adjacentes a la casilla en la que se ha hecho click\n    // pertenece al jugador\n    return validClick.some(el => el.validCell)\n  }\n\n  checkCellClick ( e )\n  {\n    // chequeamos a que jugador le toca\n    const currentPlayerTurn = this.round.player;\n\n    // sacamos la id de la celda dentro del DOM\n    // sacamos los data asciados al número de row y la celda\n    const cellId = e.target.id;\n    const cellObj = {\n      row: e.target.dataset.row,\n      cell: e.target.dataset.cell\n    }\n    const cell = document.getElementById(cellId);\n\n    // comprobamos si es adjacente a la última seleccionada por el jugador\n    // siempre y cuando no sea el primer turno\n    if(this.round.roundNumber !== 1){\n      let isCellFilled, isAValidCellClick;\n      // comprobamos si está llena\n      isCellFilled = cell.classList.contains('isFilled')\n      // comprobamos si el click está en una casilla adjacente que pertenece al jugador\n      isAValidCellClick = this.checkValidCellClick(cellObj, currentPlayerTurn);\n\n      if(isCellFilled || !isAValidCellClick) {\n        return\n      };\n    }\n\n    // Añadimos la class isFilled que no permite pulsar la casilla\n    cell.classList.add('isFilled');\n    // Cambiamos la celda al color del jugador\n    cell.style.backgroundColor= currentPlayerTurn.color;\n    // Le sumamos 1 a sus casillas conquistadas\n    // y registramos la id de la celda como última posición\n    this.AddConqueredCell(currentPlayerTurn.id, cellId);\n\n    // Comprobamos si ha ganado\n    if(this.totalCellsToWin === currentPlayerTurn.cellsConquered){\n      console.log('El jugador 1 ha ganado!!!')\n    }\n\n    // cambiamos el turno\n    this.checkTurn()\n\n  }\n\n  AddConqueredCell(playerId, cellId){\n    this.players = this.players.map(player => {\n      if(player.id === playerId){\n        player.cellsConquered += 1;\n      }\n      return player;\n    })\n    this.grid.forEach(cell => {\n      if(cell.id === cellId){\n        cell.playerId = this.round.player.id\n      }\n    })\n  }\n\n  createDomGrid ()\n  {\n    const size = this.gridSize;\n    const wrapper = document.getElementById( this.wrapper );\n    let rowCounter = 1;\n    let cellCounter = 1;\n    let cells = []\n\n    for ( let i = 1; i <= size * size; i++ ) {\n      let cellId = `cell${ rowCounter }-${ cellCounter }`;\n      let cell = document.createElement( 'div' );\n      cell.id = cellId;\n      cell.className = `m-game-grid__cell cell-${rowCounter}-${cellCounter}`;\n      cell.dataset.cell = cellCounter;\n      cell.dataset.row = rowCounter;\n      cell.addEventListener( 'click', this.checkCellClick.bind( this ), false );\n      cells.push(cell);\n      cellCounter++;\n\n      // Si hay 20 celdas\n      if ( i % size === 0) {\n        // Creamos contenedor de la fila\n        let row = document.createElement( 'div' );\n        row.className = 'm-game-grid__row';\n\n        // Añadimos las 20 celdas a la fila\n        cells.forEach((cell, index) => {\n          row.appendChild(cell);\n        });\n\n        // Añadimos la fila al grid del HTML\n        wrapper.appendChild( row )\n\n        // Reiniciamos el array de celdas, \n        // el contador de celdas a 1 \n        // y añadimos 1 al contador de filas\n        cells = [];\n        cellCounter = 1;\n        rowCounter++;\n      }\n\n      // registamos la id de la casilla en nuestro registro de grid\n      this.grid[i-1] = {\n        id: cell.id,\n        playerId: null\n      }\n    }\n  }\n\n  generateGrid(gridSize){\n    return [...Array(gridSize * gridSize)]\n  }\n\n  buildToGamePlayers ( players )\n  {\n    return players.map( ( player, index ) => ( {\n      id: uuidv4(),\n      name: player.getName(),\n      cellsConquered: 0,\n      color: this.colors[ index ]\n    } ) )\n  }\n\n  calculateTotalCellsToWin ( totalCells, players )\n  {\n    const numPlayers = players.length;\n\n    return Math.floor( totalCells / numPlayers ) + 1\n  }\n\n  init(){\n    this.createDomGrid();\n  }\n}\n\nexport default Game;","class Player {\n  name = \"\";\n  avatar = \"\";\n\n  constructor(\n    name,\n    avatar\n  ){\n    this.name = name;\n    this.avatar = avatar;\n  }\n\n  getName(){\n    return this.name;\n  }\n\n  getAvatar(){\n    return this.avatar;\n  }\n}\n\nexport default Player;","import { v4 as uuidv4 } from 'uuid';\n\nclass Room {\n  capacity = 4;\n  status = true;\n  players = [];\n  roomBox = \"\";\n\n  constructor(id, name, capacity){\n    this.name = name;\n    this.capacity = capacity;\n    this.roomBox = id;\n  }\n\n  addPlayer(player){\n    this.players.push(player)\n  }\n\n  getPlayers(){\n    return players;\n  }\n}\n\nexport default Room;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// extracted by mini-css-extract-plugin\nexport {};","import Game from './Game';\nimport Player from './Player';\nimport Room from './Room';\nimport Dashboard from './DashBoard';\n\nexport {\n  Game, \n  Player,\n  Room,\n  Dashboard\n}"],"names":[],"sourceRoot":""}